{
    "initializeAncestralNucleotides": {
        "signature": "(integer$)initializeAncestralNucleotides(is sequence)",
        "description": "This function, which may be called only in nucleotide-based models, supplies an ancestral nucleotide sequence for the model.Thesequenceparameter may be anintegervector providing nucleotide values (A=0, C=1, G=2, T=3), or astringvector providing single-character nucleotides (\"A\",\"C\",\"G\",\"T\"), or a singletonstringproviding the sequence as one string (\"ACGT...\"), or a singletonstringproviding the filesystem path of a FASTA file which will be read in to provide the sequence (if the file contains than one sequence, the first sequence will be used).Only A/C/G/T nucleotide values may be provided; other symbols, such as those for amino acids, gaps, or nucleotides of uncertain identity, are not allowed.The two semantic meanings ofsequencethat involve a singletonstringvalue are distinguished heuristically; a singletonstringthat contains only the letters ACGT will be assumed to be a nucleotide sequence rather than a filename.The length of the ancestral sequence is returned.\n\nA utility function,randomNucleotides(), is provided by SLiM to assist in generating simple random nucleotide sequences.\n\n"
    },
    "initializeGeneConversion": {
        "signature": "(void)initializeGeneConversion(numeric$ nonCrossoverFraction, numeric$ meanLength, numeric$ simpleConversionFraction, [numeric$ bias = 0], [logical$ redrawLengthsOnFailure = F])",
        "description": "Calling this function switches the recombination model from a “simple crossover” model to a “double-stranded break (DSB)” model, and configures the details of the gene conversion tracts that will therefore be modeled.The fraction of DSBs that will be modeled as non-crossover events is given bynonCrossoverFraction.The mean length of gene conversion tracts (whether associated with crossover or non-crossover events) is given bymeanLength; the actual extent of a gene conversion tract will be the sum of two independent draws from a geometric distribution with meanmeanLength/2.The fraction of gene conversion tracts that are modeled as “simple” is given bysimpleConversionFraction; the remainder will be modeled as “complex”, involving repair of heteroduplex mismatches.Finally, theGCbias during heteroduplex mismatch repair is given bybias, with the default of0.0indicating no bias,1.0indicating an absolute preference forG/Cmutations overA/Tmutations, and-1.0indicating an absolute preference forA/Tmutations overG/Cmutations.A non-zero bias may only be set in nucleotide-based models.This function, and the way that gene conversion is modeled, fundamentally changed in SLiM 3.3.\n\nBeginning in SLiM 4.1, theredrawLengthsOnFailureparameter can be used to modify the internal mechanics of layout of gene conversion tracts.If it isF(the default, and the only behavior supported before SLiM 4.1), then if an attempt to lay out gene conversion tracts fails (because the tracts overlap each other, or overlap the start or end of the chromosome), SLiM will try again by drawing new positions for the tracts – essentially shuffling the tracts around to try to find positions for them that don’t overlap.IfredrawLengthsOnFailureisT, then if an attempt to lay out gene conversion tracts fails, SLiM will try again by drawing new lengths for the tracts, as well as new positions.This makes it more likely that layout will succeed, but risks biasing the realized mean tract length downward from the requested mean length (since layout of long tracts is more likely fail due to overlap).In either case, if SLiM attempts to lay out gene conversion tracts 100 times without success, an error will result.That error indicates that the specified constraints for gene conversion are difficult to satisfy – tracts may commonly be so long that it is difficult or impossible to find an acceptable layout for them within the specified chromosome length.SettingredrawLengthsOnFailuretoTmay mitigate this problem, at the price of biasing the mean tract length downward as discussed.\n\n"
    },
    "initializeGenomicElement": {
        "signature": "(object<GenomicElement>)initializeGenomicElement(io<GenomicElementType> genomicElementType, integer start, integer end)",
        "description": "Add a genomic element to the chromosome at initialization time.Thestartandendparameters give the first and last base positions to be spanned by the new genomic element.The new element will be based upon the genomic element type identified bygenomicElementType, which can be either aninteger, representing the ID of the desired element type, or anobjectof typeGenomicElementTypespecified directly.\n\nBeginning in SLiM 3.3, this function is vectorized: thegenomicElementType,start, andendparameters do not have to be singletons.In particular,startandendmay be of any length, but must be equal in length; eachstart/endelement pair will generate one new genomic element spanning the given base positions.In this case,genomicElementTypemay still be a singleton, providing the genomic element type to be used for all of the new genomic elements, or it may be equal in length tostartandend, providing an independent genomic element type for each new element.When adding a large number of genomic elements, it will be much faster to add them in order of ascending position with a vectorized call.\n\nThe return value provides the genomic element(s) created by the call, in the order in which they were specified in the parameters toinitializeGenomicElement().\n\n"
    },
    "initializeGenomicElementType": {
        "signature": "(object<GenomicElementType>$)initializeGenomicElementType(is$ id, io<MutationType> mutationTypes, numeric proportions, [Nf mutationMatrix = NULL])",
        "description": "Add a genomic element type at initialization time.Theidmust not already be used for any genomic element type in the simulation.ThemutationTypesvector identifies the mutation types used by the genomic element, and theproportionsvector should be of equal length, specifying the relative proportion of mutations that will be drawn from the corresponding mutation type (proportions do not need to add up to one; they are interpreted relatively).Theidparameter may be either anintegergiving the ID of the new genomic element type, or astringgiving the name of the new genomic element type (such as\"g5\"to specify an ID of 5).ThemutationTypesparameter may be either anintegervector representing the IDs of the desired mutation types, or anobjectvector ofMutationTypeelements specified directly.The global symbol for the new genomic element type is immediately available; the return value also provides the new object.\n\nThemutationMatrixparameter isNULLby default, and in non-nucleotide-based models it must beNULL.In nucleotide-based models, on the other hand, it must be non-NULL, and therefore must be supplied.In that case,mutationMatrixshould take one of two standard forms.For sequence-based mutation rates that depend upon only the single nucleotide at a mutation site,mutationMatrixshould be a 4×4floatmatrix, specifying mutation rates for an existing nucleotide state (rows from0–3representing A/C/G/T) to each of the four possible derived nucleotide states (columns, with the same meaning).The mutation rates in this matrix are absolute rates, per nucleotide per gamete; they will be used by SLiM directly unless they are multiplied by a factor from the hotspot map (seeinitializeHotspotMap()).Rates inmutationMatrixthat involve the mutation of a nucleotide to itself (AtoA,CtoC, etc.) are not used by SLiM and must be0.0by convention.\n\nIt is important to note that the order of the rows and columns used in SLiM, A/C/G/T, is not a universal convention; other sources will present substitution-rate/transition-rate matrices using different conventions, and so care must be taken when importing such matrices into SLiM.\n\nFor sequence-based mutation rates that depend upon the trinucleotide sequence centered upon a mutation site (the adjacent bases to the left and right, in other words, as well as the mutating nucleotide itself),mutationMatrixshould be a 64×4floatmatrix, specifying mutation rates for the central nucleotide of an existing trinucleotide sequence (rows from0–63, representing codons as described in the documentation for theancestralNucleotides()method ofChromosome) to each of the four possible derived nucleotide states (columns from0–3for A/C/G/T as before).Note that in every case it is the central nucleotide of the trinucleotide sequence that is mutating, but rates can be specified independently based upon the nucleotides in the first and third positions as well, with this type of mutation matrix.\n\nSeveral helper functions are defined to construct common types of mutation matrices, such asmmJukesCantor()to create a mutation matrix for a Jukes–Cantor model.\n\n"
    },
    "initializeHotspotMap": {
        "signature": "(void)initializeHotspotMap(numeric multipliers, [Ni ends = NULL], [string$ sex = \"*\"])",
        "description": "In nucleotide-based models, set the mutation ratemultiplieralong the chromosome.Nucleotide-based models define sequence-based mutation rates that are set up with themutationMatrixparameter toinitializeGenomicElementType().If no hotspot map is specified by callinginitializeHotspotMap(), a hotspot map with a multiplier of1.0across the whole chromosome is assumed (and so the sequence-based rates are the absolute mutation rates used by SLiM).A hotspot map modifies the sequence-based rates by scaling them up in some regions, with multipliers greater than1.0(representing mutational hot spots), and/or scaling them down in some regions, with multipliers less than1.0(representing mutational cold spots).\n\nThere are two ways to call this function.If the optionalendsparameter isNULL(the default), thenmultipliersmust be a singleton value that specifies a single multiplier to be used along the entire chromosome (typically1.0, but not required to be).If, on the other hand,endsis supplied, thenmultipliersandendsmust be the same length, and the values inendsmust be specified in ascending order.In that case,multipliersandendstaken together specify the multipliers to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified inendsshould extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further).\n\nFor example, if the following call is made:\n\ninitializeHotspotMap(c(1.0, 1.2), c(5000, 9999));\n\nthen the result is that the mutation rate multiplier for bases0...5000(inclusive) will be1.0(and so the specified sequence-based mutation rates will be used verbatim), and the multiplier for bases5001...9999(inclusive) will be1.2(and so the sequence-based mutation rates will be multiplied by 1.2 within the region).\n\nNote that mutations are generated by SLiM only within genomic elements, regardless of the hotspot map.In effect, the hotspot map given is intersected with the coverage area of the genomic elements defined; areas outside of any genomic element are given a multiplier of zero.There is no harm in supplying a hotspot map that specifies multipliers for areas outside of the genomic elements defined; the excess information is simply not used.\n\nIf the optionalsexparameter is\"*\"(the default), then the supplied hotspot map will be used for both sexes (which is the only option for hermaphroditic simulations).In sexual simulationssexmay be\"M\"or\"F\"instead, in which case the supplied hotspot map is used only for that sex (i.e., when generating a gamete from a parent of that sex).In this case, two calls must be made toinitializeHotspotMap(), one for each sex, even if a multiplier of1.0is desired for the other sex; no default hotspot map is supplied.\n\n"
    },
    "initializeInteractionType": {
        "signature": "(object<InteractionType>$)initializeInteractionType(is$ id, string$ spatiality, [logical$ reciprocal = F], [numeric$ maxDistance = INF], [string$ sexSegregation = \"**\"])",
        "description": "Add an interaction type at initialization time.Theidmust not already be used for any interaction type in the simulation.Theidparameter may be either anintegergiving the ID of the new interaction type, or astringgiving the name of the new interaction type (such as\"i5\"to specify an ID of 5).\n\nThespatialitymay be\"\", for non-spatial interactions (i.e., interactions that do not depend upon the distance between individuals);\"x\",\"y\", or\"z\"for one-dimensional interactions;\"xy\",\"xz\", or\"yz\"for two-dimensional interactions; or\"xyz\"for three-dimensional interactions.The dimensions referenced by spatiality must be defined as spatial dimensions withinitializeSLiMOptions(); if the simulation has dimensionality\"xy\", for example, then interactions in the simulation may have spatiality\"\",\"x\",\"y\", or\"xy\", but may not reference spatial dimensionzand thus may not have spatiality\"xz\",\"yz\", or\"xyz\".If no spatial dimensions have been configured, only non-spatial interactions may be defined.\n\nThereciprocalflag may beT, in which case the interaction is guaranteed by the user to bereciprocal: whatever the interaction strength is for exerter B upon receiver A, it will be equal (in magnitude and sign) for exerter A upon receiver B.In principle, this allows theInteractionTypeto reduce the amount of computation necessary by up to a factor of two (although it may or may not be used).IfreciprocalisF, the interaction is not guaranteed to be reciprocal and each interaction will be computed independently.The built-in interaction formulas are all reciprocal, but if you implement aninteraction()callback, you must consider whether the callback you have implemented preserves reciprocality or not.For this reason, the default isreciprocal=F, so that bugs are not inadvertently introduced by an invalid assumption of reciprocality.See below for a note regarding reciprocality in sexual simulations when using thesexSegregationflag.\n\nThemaxDistanceparameter supplies the maximum distance over which interactions of this type will be evaluated; at greater distances, the interaction strength is considered to be zero (for efficiency).The default value ofmaxDistance,INF(positive infinity), indicates that there is no maximum interaction distance; note that this can make some interaction queries much less efficient, and is therefore not recommended.In SLiM 3.1 and later, a warning will be issued if a spatial interaction type is defined with no maximum distance to encourage a maximum distance to be defined.\n\nThesexSegregationparameter governs the applicability of the interaction to each sex, in sexual simulations.It does not affect distance calculations in any way; it only modifies the way in which interaction strengths are calculated.The default,\"**\", implies that the interaction is felt by both sexes (the first character of thestringvalue) and is exerted by both sexes (the second character of thestringvalue).Either or both characters may beMorFinstead; for example,\"MM\"would indicate a male-male interaction, such as male-male competition, whereas\"FM\"would indicate an interaction influencing only female receivers that is influenced only by male exerters, such as male mating displays that influence female attraction.This parameter may be set only to\"**\"unless sex has been enabled withinitializeSex().Note that a value ofsexSegregationother than\"**\"may imply some degree of non-reciprocality, but it is not necessary to specifyreciprocalto beFfor this reason; SLiM will take the sex-segregation of the interaction into account for you.The value ofreciprocalmay therefore be interpreted as meaning: in those cases, if any, in which A interacts with B and B interacts with A, is the interaction strength guaranteed to be the same in both directions?ThesexSegregationparameter is shorthand for setting sex constraints on the interaction type using thesetConstraints()method; see that method for a more extensive set of constraints that may be used.\n\nBy default, the interaction strength is1.0for all interactions withinmaxDistance.Often it is desirable to change the interaction function usingsetInteractionFunction(); modifying interaction strengths can also be achieved withinteraction()callbacks if necessary.In any case, interactions beyondmaxDistancealways have a strength of0.0, and the interaction strength of an individual with itself is always0.0, regardless of the interaction function or callbacks.\n\nThe global symbol for the new interaction type is immediately available; the return value also provides the new object.Note that in multispecies models,initializeInteractionType()must be called from a non-species-specificinteraction()callback (declared asspecies all initialize()), since interactions are managed at the community level.\n\n"
    },
    "initializeMutationRate": {
        "signature": "(void)initializeMutationRate(numeric rates, [Ni ends = NULL], [string$ sex = \"*\"])",
        "description": "Set the mutation rate per base position per gamete.To be precise, this mutation rate is the expected mean number of mutations that will occur per base position per gamete; note that this is different from how the recombination rate is defined (seeinitializeRecombinationRate()).The number of mutations that actually occurs at a given base position when generating an offspring genome is, in effect, drawn from a Poisson distribution with that expected mean (but under the hood SLiM uses a mathematically equivalent but much more efficient strategy).It is possible for this Poisson draw to indicate that two or more new mutations have arisen at the same base position, particularly when the mutation rate is very high; in this case, the new mutations will be added to the site one at a time, and as always the mutation stacking policy will be followed.\n\nThere are two ways to call this function.If the optionalendsparameter isNULL(the default), thenratesmust be a singleton value that specifies a single mutation rate to be used along the entire chromosome.If, on the other hand,endsis supplied, thenratesandendsmust be the same length, and the values inendsmust be specified in ascending order.In that case,ratesandendstaken together specify the mutation rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified inendsshould extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further).\n\nFor example, if the following call is made:\n\ninitializeMutationRate(c(1e-7, 2.5e-8), c(5000, 9999));\n\nthen the result is that the mutation rate for bases0...5000(inclusive) will be1e-7, and the rate for bases5001...9999(inclusive) will be2.5e-8.\n\nNote that mutations are generated by SLiM only within genomic elements, regardless of the mutation rate map.In effect, the mutation rate map given is intersected with the coverage area of the genomic elements defined; areas outside of any genomic element are given a mutation rate of zero.There is no harm in supplying a mutation rate map that specifies rates for areas outside of the genomic elements defined; that rate information is simply not used.TheoverallMutationRatefamily of properties onChromosomeprovide the overall mutation rate after genomic element coverage has been taken into account, so it will reflect the rate at which new mutations will actually be generated in the simulation as configured.\n\nIf the optionalsexparameter is\"*\"(the default), then the supplied mutation rate map will be used for both sexes (which is the only option for hermaphroditic simulations).In sexual simulationssexmay be\"M\"or\"F\"instead, in which case the supplied mutation rate map is used only for that sex (i.e., when generating a gamete from a parent of that sex).In this case, two calls must be made toinitializeMutationRate(), one for each sex, even if a rate of zero is desired for the other sex; no default mutation rate map is supplied.\n\nIn nucleotide-based models,initializeMutationRate()may not be called.Instead, the desired sequence-based mutation rate(s) should be expressed in themutationMatrixparameter toinitializeGenomicElementType().If variation in the mutation rate along the chromosome is desired,initializeHotspotMap()should be used.\n\n"
    },
    "initializeMutationType": {
        "signature": "(object<MutationType>$)initializeMutationType(is$ id, numeric$ dominanceCoeff, string$ distributionType, ...)",
        "description": "Add a mutation type at initialization time.Theidmust not already be used for any mutation type in the simulation.Theidparameter may be either anintegergiving the ID of the new mutation type, or astringgiving the name of the new mutation type (such as\"m5\"to specify an ID of 5).The dominanceCoeff parameter supplies the dominance coefficient for the mutation type;0.0produces no dominance,1.0complete dominance, and values greater than1.0, overdominance.ThedistributionTypemay be\"f\", in which case the ellipsis...should supply anumeric$fixed selection coefficient;\"e\", in which case the ellipsis should supply anumeric$mean selection coefficient for an exponential distribution;\"g\", in which case the ellipsis should supply anumeric$mean selection coefficient and anumeric$alpha shape parameter for a gamma distribution;\"n\", in which case the ellipsis should supply anumeric$mean selection coefficient and anumeric$sigma (standard deviation) parameter for a normal distribution;\"p\", in which case the ellipsis should supply anumeric$mean selection coefficient and anumeric$scale parameter for a Laplace distribution;\"w\", in which case the ellipsis should supply anumeric$λscale parameter and anumeric$k shape parameter for a Weibull distribution; or\"s\", in which case the ellipsis should supply astring$Eidos script parameter.The global symbol for the new mutation type is immediately available; the return value also provides the new object.\n\nNote that by default in WF models, all mutations of a given mutation type will be converted intoSubstitutionobjects when they reach fixation, for efficiency reasons.If you need to disable this conversion, to keep mutations of a given type active in the simulation even after they have fixed, you can do so by setting theconvertToSubstitutionproperty ofMutationTypetoF.In contrast, by default in nonWF models mutations will not be converted intoSubstitutionobjects when they reach fixation;convertToSubstitutionisFby default in nonWF models.To enable conversion in nonWF models for neutral mutation types with no indirect fitness effects, you should therefore setconvertToSubstitutiontoT.\n\n"
    },
    "initializeMutationTypeNuc": {
        "signature": "(object<MutationType>$)initializeMutationTypeNuc(is$ id, numeric$ dominanceCoeff, string$ distributionType, ...)",
        "description": "Add a nucleotide-based mutation type at initialization time.This function is identical toinitializeMutationType()except that the new mutation type will be nucleotide-based – in other words, mutations belonging to the new mutation type will have an associated nucleotide.This function may be called only in nucleotide-based models (as enabled by thenucleotideBasedparameter toinitializeSLiMOptions()).\n\nNucleotide-based mutations always use amutationStackGroupof-1and amutationStackPolicyof\"l\".This ensures that a new nucleotide mutation always replaces any previously existing nucleotide mutation at a given position, regardless of the mutation types of the nucleotide mutations.These values are set automatically byinitializeMutationTypeNuc(), and may not be changed.\n\nSee the documentation forinitializeMutationType()for all other discussion.\n\n"
    },
    "initializeRecombinationRate": {
        "signature": "(void)initializeRecombinationRate(numeric rates, [Ni ends = NULL], [string$ sex = \"*\"])",
        "description": "Set the recombination rate per base position per gamete.To be precise, this recombination rate is the probability that a breakpoint will occur between one base and the next base; note that this is different from how the mutation rate is defined (seeinitializeMutationRate()).A recombination rate of 1 centimorgan/Mbp corresponds to a recombination rate of1e-8in the units used by SLiM.All rates must be in the interval [0.0,0.5].A rate of0.5implies complete independence between the adjacent bases, which might be used to implement independent assortment of loci located on different chromosomes (see the example below).Whether a breakpoint occurs between two bases is then, in effect, determined by a binomial draw with a single trial and the given rate as probability (but under the hood SLiM uses a mathematically equivalent but much more efficient strategy).The recombinational process in SLiM will never generate more then one crossover between one base and the next (in one generation/genome), and a supplied rate of0.5will therefore result in an actual probability of0.5for a crossover at the relevant position.(Note that this was not true in SLiM 2.x and earlier, however; their implementation of recombination resulted in a crossover probability of about 39.3% for a rate of0.5, due to the use of an inaccurate approximation method.Recombination rates lower than about0.01would have been essentially exact, since the approximation error became large only as the rate approached0.5.)\n\nThere are two ways to call this function.If the optionalendsparameter isNULL(the default), thenratesmust be a singleton value that specifies a single recombination rate to be used along the entire chromosome.If, on the other hand,endsis supplied, thenratesandendsmust be the same length, and the values inendsmust be specified in ascending order.In that case,ratesandendstaken together specify the recombination rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified inendsshould extend to the end of the chromosome (i.e. at least to the end of the last genomic element, if not further).\n\nFor example, if the following call is made:\n\ninitializeRecombinationRate(c(0, 0.5, 0), c(5000, 5001, 9999));\n\nthen the result is that the recombination rates between bases0/1,1/2, ...,4999/5000will be0, the rate between bases5000/5001will be0.5, and the rate between bases5001/5002onward (up to9998/9999) will again be0.Setting the recombination rate between one specific pair of bases to0.5forces recombination to occur with a probability of0.5between those bases, which effectively breaks the simulated locus into separate chromosomes at that point; this example effectively has one simulated chromosome from base position0to5000, and another from5001to9999.\n\nIf the optionalsexparameter is\"*\"(the default), then the supplied recombination rate map will be used for both sexes (which is the only option for hermaphroditic simulations).In sexual simulationssexmay be\"M\"or\"F\"instead, in which case the supplied recombination map is used only for that sex.In this case, two calls must be made toinitializeRecombinationRate(), one for each sex, even if a rate of zero is desired for the other sex; no default recombination map is supplied.\n\n"
    },
    "initializeSex": {
        "signature": "(void)initializeSex(string$ chromosomeType)",
        "description": "Enable and configure sex in the simulation.The argumentchromosomeTypegives the type of chromosome to be simulated; this should be\"A\",\"X\", or\"Y\".Calling this function has the side effect of enabling sex in the simulation; individuals will be male and female (rather than hermaphroditic) regardless of thechromosomeTypechosen for simulation.There is no way to disable sex once it has been enabled; if you don’t want to have sex, don’t call this function.\n\nThexDominanceCoeffparameter has been deprecated and removed.In SLiM 3.7 and later, use thehaploidDominanceCoeffproperty ofMutationTypeinstead.If thechromosomeTypeis\"X\", the optionalxDominanceCoeffparameter can supply the dominance coefficient used when a mutation is present in an XY male, and is thus “heterozygous” (but in a different sense than the heterozygosity of an XX female with one copy of the mutation).\n\n"
    },
    "initializeSLiMModelType": {
        "signature": "(void)initializeSLiMModelType(string$ modelType)",
        "description": "Configure the type of SLiM model used for the simulation.At present, one of two model types may be selected.IfmodelTypeis\"WF\", SLiM will use a Wright-Fisher (WF) model; this is the model type that has always been supported by SLiM, and is the model type used ifinitializeSLiMModelType()is not called.IfmodelTypeis\"nonWF\", SLiM will use a non-Wright-Fisher (nonWF) model instead; this is a new model type supported by SLiM 3.0 and above.\n\nIfinitializeSLiMModelType()is called at all then it must be called before any other initialization function, so that SLiM knows from the outset which features are enabled and which are not.\n\n"
    },
    "initializeSLiMOptions": {
        "signature": "(void)initializeSLiMOptions([logical$ keepPedigrees = F], [string$ dimensionality = \"\"], [string$ periodicity = \"\"], [integer$ mutationRuns = 0], [logical$ preventIncidentalSelfing = F], [logical$ nucleotideBased = F], [logical$ randomizeCallbacks = T])",
        "description": "Configure options for the simulation.IfinitializeSLiMOptions()is called at all then it must be called before any other initialization function (exceptinitializeSLiMModelType()), so that SLiM knows from the outset which optional features are enabled and which are not.\n\nIfkeepPedigreesisT, SLiM will keep pedigree information for every individual in the simulation, tracking the identity of its parents and grandparents.This allows individuals to assess their degree of pedigree-based relatedness to other individuals (seeIndividual’srelatedness()andsharedParentCount()methods), as well as allowing a model to find “trios” (two parents and an offspring they generated) using the pedigree properties ofIndividual.As a side effect ofkeepPedigreesbeingT, thepedigreeID,pedigreeParentIDs, andpedigreeGrandparentIDsproperties ofIndividualwill have defined values, as will thegenomePedigreeIDproperty ofGenome.Note that pedigree-based relatedness doesn’t necessarily correspond to genetic relatedness, due to effects such as assortment and recombination.Beginning in SLiM 3.5,keepPedigrees=Talso enables tracking of individual reproductive output, available through thereproductiveOutputproperty ofIndividualand thelifetimeReproductiveOutputproperty ofSubpopulation.\n\nIfdimensionalityis not\"\", SLiM will enable its optional “continuous space” facility.Three values fordimensionalityare presently supported:\"x\",\"xy\", and\"xyz\", specifying that continuous space should be enabled for one, two, or three dimensions, respectively, using (x), (x,y), and (x,y,z) coordinates respectively.This has a number of side effects.First of all, it means that the specified properties ofIndividual(x,y, and/orz) will be interpreted by SLiM as spatial positions; in particular, SLiMgui will use those properties to display subpopulations spatially.Second, it allows spatial interactions to be defined, evaluated, and queried usinginitializeInteractionType()andinteraction()callbacks.And third, it enables the use of any other properties and methods related to continuous space, such as setting the spatial boundaries of subpopulations, which would otherwise raise an error.\n\nIfperiodicityis not\"\", SLiM will designate the specified spatial dimensions as being periodic – wrapping around at the edges of the spatial boundaries of that dimension.This option may only be used if thedimensionalityparameter toinitializeSLiMOptions()has been used to enable spatiality in the model, and only spatial dimensions that were specified in the dimensionality of the model may be declared to be periodic (but if desired, it is permissible to make just a subset of those dimensions periodic; it is not an all-or-none proposition).For example, if the specified dimensionality is\"xy\", the model’s periodicity may be\"x\",\"y\", or\"xy\"(or\"\", the default, to specify that there are no periodic dimensions).A one-dimensional periodic model would model a space like the perimeter of a circle.A two-dimensional model periodic in one of those dimensions would model a space like a cylinder without its end caps; if periodic in both dimensions, the modeled space is a torus.The shapes of three-dimensional periodic models are harder to visualize, but are essentially higher-dimensional analogues of these concepts.Periodic boundary conditions are commonly used to model spatial scenarios without “edge effects”, since there are no edges in the periodic spatial dimensions.ThepointPeriodic()method ofSubpopulationis typically used in conjunction with this option, to actually implement the periodic boundary condition for the specified dimensions.\n\nIfmutationRunsis not0, SLiM will use the value given as the number of mutation runs insideGenomeobjects; if it is0(the default), SLiM will calculate a number of mutation runs that it estimates will work well.Internally, SLiM divides genomes into a sequence of consecutive mutation runs, allowing more efficient internal computations.The optimal mutation run length is short enough that each mutation run is relatively unlikely to be modified by mutation/recombination events when inherited, but long enough that each mutation run is likely to contain a relatively large number of mutations; these priorities are in tension, so an intermediate balance between them is generally desirable.The optimal number of mutation runs will depend upon the machine and even the compiler used to build SLiM, so SLiM’s default value may not be optimal; for maximal performance it can thus be beneficial to experiment with different values and find the optimal value for the simulation.Specifying the number of mutation runs is an advanced technique, but in certain cases it can improve performance significantly; in particular, if a simulation involves a very long chromosome but only a small portion of that chromosome is actually used by the simulation, it may be beneficial to specify that a single mutation run be used withmutationRuns=1.\n\nIfpreventIncidentalSelfingisT, incidental selfing in hermaphroditic models will be prevented by SLiM.By default (i.e., ifpreventIncidentalSelfingisF), SLiM chooses the first and second parents in a biparental mating event independently.It is therefore possible for the same individual to be chosen as both the first and second parent, resulting in selfing events even when the selfing rate is zero.In many models this is unimportant, since it happens fairly infrequently and does not have large consequences.This behavior is SLiM’s default because it is the simplest option, and produces results that most closely align with simple analytical population genetics models.However, in some models this selfing can be undesirable and problematic.In particular, models that involve very high variance in fitness or very small effective population sizes may see elevated rates of selfing that substantially influence model results.IfpreventIncidentalSelfingis set toT, all such incidental selfing will be prevented (by choosing a new second parent if the first parent was chosen again).Non-incidental selfing, as requested by the selfing rate, will still be permitted.Note that if incidental selfing is prevented, SLiM will hang if it is unable to find a different second parent; there must always be at least two individuals in the population with non-zero fitness, andmateChoice()andmodifyChild()callbacks must not absolutely prevent those two individuals from producing viable offspring.Enforcement of the prohibition on incidental selfing will occur aftermateChoice()callbacks have been called (and thus the default mating weights provided tomateChoice()callbacks willnotexclude the first parent!), but will occur beforemodifyChild()callbacks are called (so those callbacks may assume that the first and second parents are distinct).\n\nIfnucleotideBasedisT, the model will be nucleotide-based.In this case, auto-generated mutations (i.e., mutation types used by genomic element types) must be nucleotide-based, and an ancestral nucleotide sequence must be supplied withinitializeAncestralNucleotides().Non-nucleotide-based mutations may still be used, but may not be referenced by genomic element types.A mutation rate (or rate map) may not be supplied withinitializeMutationRate(); instead, a hotspot map may (optionally) be supplied withinitializeHotspotMap().This choice has many consequences across SLiM.\n\nIfrandomizeCallbacksisT(the default), the order in which individuals are processed in callbacks will be randomized to make it easier to avoid order-dependency bugs.This flag exists because the order of individuals in each subpopulation is non-random; most notably, females always come before males in the individuals vector, but non-random ordering may also occur with respect to things like migrant versus non-migrant status, origin by selfing versus cloning versus biparental mating, and other factors.When this option isF, individuals in a subpopulation are processed in the order of the individuals vector in each tick cycle stage, which may lead to order-dependency issues if there is an enabled callback whose behavior is not fully independent between calls.Setting this option toTwill cause individuals within each subpopulation to be processed in a randomized order in each tick cycle stage; specifically, this randomizes the order of calls tomutationEffect()callbacks in both WF and nonWF models, and calls toreproduction()andsurvival()callbacks in nonWF models.Each subpopulation is still processed separately, in sequential order, so order-dependency issues between subpopulations are still possible if callbacks have effects that are not fully independent.This feature was added in SLiM 4, breaking backward compatibility; to recover the behavior of previous versions of SLiM, passFfor this option (but then be very careful about order-dependency issues in your script).The default ofTis the safe option, but a small speed penalty is incurred by the randomization of the processing order – for most models the difference will be less than 1%, but in the worst case it may approach 10%.Models that do not have any order-dependency issue may therefore run somewhat faster if this is set toF.Note that anywhere that your script uses theindividualsproperty ofSubpopulation, the order of individuals returned will be non-random (regardless of the setting of this option); you should usesample()to shuffle the order of the individuals vector if necessary to avoid order-dependency issues in your script.\n\nThis function will likely be extended with further options in the future, added on to the end of the argument list.Using named arguments with this call is recommended for readability.Note that turning on optional features may increase the runtime and memory footprint of SLiM.\n\n"
    },
    "initializeSpecies": {
        "signature": "(void)initializeSpecies([integer$ tickModulo = 1], [integer$ tickPhase = 1], [string$ avatar = \"\"], [string$ color = \"\"])",
        "description": "Configure options for the species being initialized.This initialization function may only be called in multispecies models (i.e., models with explicit species declarations); in single-species models, the default values are assumed and cannot be changed.\n\nThetickModuloandtickPhaseparameters determine the activation schedule for the species.Theactiveproperty of the species will be set toT(thus activating the species) everytickModuloticks, beginning in ticktickPhase.(However, when the species is activated in a given tick, theskipTick()method may still be called in afirst()event to deactivate it.)See theactiveproperty ofSpeciesfor more details.\n\nTheavatarparameter, if not\"\", sets astringvalue used to represent the species graphically, particularly in SLiMgui but perhaps in other contexts also.Theavatarshould generally be a single character – usually an emoji corresponding to the species, such as\"🦊\"for foxes or\"🐭\"for mice.Ifavataris the empty string,\"\", SLiMgui will choose a default avatar.\n\nThecolorparameter, if not\"\", sets astringcolor value used to represent the species in SLiMgui.Colors may be specified by name, or with hexadecimal RGB values of the form\"#RRGGBB\"(see the Eidos manual for details).Ifcoloris the empty string,\"\", SLiMgui will choose a default color.\n\n"
    },
    "initializeTreeSeq": {
        "signature": "(void)initializeTreeSeq([logical$ recordMutations = T], [Nif$ simplificationRatio = NULL], [Ni$ simplificationInterval = NULL], [logical$ checkCoalescence = F], [logical$ runCrosschecks = F], [logical$retainCoalescentOnly= T], [Ns$ timeUnit = NULL])",
        "description": "Configure options for tree sequence recording.Calling this function turns on tree sequence recording, as a side effect, for later reconstruction of the simulation’s evolutionary dynamics; if you do not want tree sequence recording to be enabled, do not call this function. Note that tree-sequence recording internally uses SLiM’s “pedigree tracking” feature to uniquely identify individuals and genomes; however, if you want to use pedigree tracking in your script you must still enable it yourself withinitializeSLiMOptions(keepPedigrees=T).\n\nTherecordMutationsflag controls whether information about individual mutations is recorded or not.Such recording takes time and memory, and so can be turned off if only the tree sequence itself is needed, but it is turned on by default since mutation recording is generally useful.\n\nThesimplificationRatioandsimplificationIntervalparameters control how often automatic simplification of the recorded tree sequence occurs.This is a speed–memory tradeoff: more frequent simplification (lowersimplificationRatioor smallersimplificationInterval) means the stored tree sequences will use less memory, but at a cost of somewhat longer run times.Conversely, a largersimplificationRatioorsimplificationIntervalmeans that SLiM will wait longer between simplifications.There are three ways these parameters can be used.With the first option, with a non-NULLsimplificationRatioand aNULLvalue forsimplificationInterval, SLiM will try to find an optimal tick interval for simplification such that the ratio of the memory used by the tree sequence tables, (before:after) simplification, is close to the requested ratio. The default of10(used if bothsimplificationRatioandsimplificationIntervalareNULL) thus requests that SLiM try to find a tick interval such that the maximum size of the stored tree sequences is ten times the size after simplification.INFmay be supplied to indicate that automatic simplification should never occur;0may be supplied to indicate that automatic simplification should be performed at the end of every tick.Alternatively – the second option –simplificationRatiomay beNULLandsimplificationIntervalmay be set to the interval, in ticks, between simplifications.This may provide more reliable performance, but the interval must be chosen carefully to avoid exceeding the available memory.ThesimplificationIntervalvalue may be a very large number to specify that simplification should never occur (notINF, though, since it is anintegervalue), or1to simplify every tick.Finally – the third option – both parameters may be non-NULL, in which casesimplificationRatiois used as described above, whilesimplificationIntervalprovides theinitialinterval first used by SLiM (and then subsequently increased or decreased to try to match the requested simplification ratio).The default initial interval, used whensimplificationIntervalisNULL, is usually20; this is chosen to be relatively frequent, and thus unlikely to lead to a memory overflow, but it can result in rather slow spool-up for models where the equilibrium simplification interval, as determined by the simplification ratio, is much longer.It can therefore be helpful to set a larger initial interval so that the early part of the model run is not excessively bogged down in simplification.\n\nThecheckCoalescenceparameter controls whether a check for full coalescence is conducted after each simplification.If a model will calltreeSeqCoalesced()to check for coalescence during its execution,checkCoalescenceshould be set toT.Since the coalescence checks entail a performance penalty, the default ofFis preferable otherwise.See the documentation fortreeSeqCoalesced()for further discussion.\n\nTherunCrosschecksparameter controls whether cross-checks between SLiM’s internal data structures and the tree-sequence recording data structures will be conducted.These two sets of data structures record much the same thing (mutations in genomes), but using completely different representations, so such cross-checks can be useful to confirm that the two data structures do indeed represent the same conceptual state.This slows down the model considerably, however, and would normally be turned on only for debugging purposes, so it is turned off by default.\n\nTheretainCoalescentOnlyparameter controls how, exactly, simplification of the tree-sequence data is performed in SLiM (both for auto-simplification and for calls totreeSeqSimplify()).More specifically, this parameter controls the behavior of simplification for individuals and genomes that have been “retained” by callingtreeSeqRememberIndividuals()with the parameterpermanent=F.The default ofretainCoalescentOnly=Thelps to keep the number of retained individuals relatively small, which is helpful if your simulation regularly flags many individuals for retaining.In this case, changingretainCoalescentOnlytoFmay dramatically increase memory usage and runtime, in a similar way to permanently remembering all the individuals.See the documentation oftreeSeqRememberIndividuals()for further discussion.\n\nThetimeUnitparameter controls the time unit stated in the tree sequence when it is saved (which can be accessed throughtskitAPIs); it has no effect on the running simulation whatsoever.The default value,NULL, means that a time unit of\"ticks\"will be used for all model types.(In SLiM 3.7 / 3.7.1,NULLimplied a time unit of\"generations\"for WF models, but\"ticks\"for nonWF models; given the new multispecies timescale parameters in SLiM 4, a default of\"ticks\"makes sense in all cases since now even in WF models one tick might not equal one biological generation.)It may be helpful to settimeUnitto\"generations\"explicitly when modeling non-overlapping generations in which one tick equals one generation, to telltskitthat the time unit does in fact represent biological generations; doing so may avoid warnings fromtskitormsprimeregarding the time unit, in cases such as recapitation where the simulation timescale is important.\n\n3.2.Nucleotide utilities\n\n"
    },
    "codonsToAminoAcids": {
        "signature": "(is)codonsToAminoAcids(integer codons, [li$ long = F], [logical$ paste = T])",
        "description": "Returns the amino acid sequence corresponding to the codon sequence incodons.Codons should be represented with values in [0,63] where AAA is0, AAC is1, AAG is2, and TTT is63; seeancestralNucleotides()for discussion of this encoding.IflongisF(the default), the standard single-letter codes for amino acids will be used (where Serine is\"S\", etc.); iflongisT, the standard three-letter codes will be used instead (where Serine is\"Ser\", etc.).Beginning in SLiM 3.5, iflongis0,integercodes will be used as follows (andpastewill be ignored):\n\nstop (TAA, TAG, TGA)0Alanine1Arginine2Asparagine3Aspartic acid (Aspartate)4Cysteine5Glutamine6Glutamic acid (Glutamate)7Glycine8Histidine9Isoleucine10Leucine11Lysine12Methionine13Phenylalanine14Proline15Serine16Threonine17Tryptophan18Tyrosine19Valine20\n\nThere does not seem to be a widely used standard for integer coding of amino acids, so SLiM just numbers them alphabetically, making stop codons0.If you want a different coding, you can make your own 64-element vector and use it to convert codons to whatever integer codes you need.Otherintegervalues oflongare reserved for future use (to support other codings), and will currently produce an error.\n\nWhenlongisTorFandpasteisT(the default), the amino acid sequence returned will be a singletonstring, such as\"LYATI\"(whenlongisF) or\"Leu-Tyr-Ala-Thr-Ile\"(whenlongisT).WhenlongisTorFandpasteisF, the amino acid sequence will instead be returned as astringvector, with one element per amino acid, such as\"L\" \"Y\" \"A\" \"T\" \"I\"(whenlongisF) or\"Leu\" \"Tyr\" \"Ala\" \"Thr\" \"Ile\"(whenlongisT).Using thepaste=Toption is considerably faster than usingpaste()in script.\n\nThis function interprets the supplied codon sequence as thesensestrand (i.e., the strand that isnottranscribed, and which mirrors the mRNA’s sequence).This uses the standard DNA codon table directly.For example, if the nucleotide sequence is CAA TTC, that will correspond to a codon vector of16 61, and will result in the amino acid sequence Gln-Phe (\"QF\").\n\n"
    },
    "codonsToNucleotides": {
        "signature": "(is)codonsToNucleotides(integer codons, [string$ format = \"string\"])",
        "description": "Returns the nucleotide sequence corresponding to the codon sequence supplied incodons.Codons should be represented with values in [0,63] where AAA is0, AAC is1, AAG is2, and TTT is63; seeancestralNucleotides()for discussion of this encoding.\n\nTheformatparameter controls the format of the returned sequence.It may be\"string\"to obtain the sequence as a singletonstring(e.g.,\"TATACG\"),\"char\"to obtain it as astringvector of single characters (e.g.,\"T\",\"A\",\"T\",\"A\",\"C\",\"G\"), or\"integer\"to obtain it as anintegervector (e.g.,3,0,3,0,1,2), using SLiM’s standard code of A=0, C=1, G=2, T=3."
    },
    "mm16To256": {
        "signature": "(float)mm16To256(float$ mutationMatrix16)",
        "description": "Returns a 64×4 mutation matrix that is functionally identical to the supplied 4×4 mutation matrix in mutationMatrix16.The mutation rate for each of the 64 trinucleotides will depend only upon the central nucleotide of the trinucleotide, and will be taken from the corresponding entry for the same nucleotide in mutationMatrix16.This function can be used to easily construct a simple trinucleotide-based mutation matrix which can then be modified so that specific trinucleotides sustain a mutation rate that does not depend only upon their central nucleotide.\n\nSee the documentation forinitializeGenomicElementType()for further discussion of how these 64×4 mutation matrices are interpreted and used.\n\n"
    },
    "mmJukesCantor": {
        "signature": "(float)mmJukesCantor(float$ alpha)",
        "description": "Returns a mutation matrix representing a Jukes–Cantor (1969) model with mutation ratealphato each possible alternative nucleotide at a site.This 2×2 matrix is suitable for use withinitializeGenomicElementType().Note that the actual mutation rate produced by this matrix is3*alpha.\n\n"
    },
    "mmKimura": {
        "signature": "(float)mmKimura(float$ alpha, float$ beta)",
        "description": "Returns a mutation matrix representing a Kimura (1980) model with transition ratealphaand transversion ratebeta.This 2×2 matrix is suitable for use withinitializeGenomicElementType().Note that the actual mutation rate produced by this model isalpha+2*beta.\n\n(integer)nucleotideCounts(is sequence)\n\nA convenience function that returns anintegervector of length four, providing the number of occurrences of A / C / G / T nucleotides, respectively, in the supplied nucleotide sequence.The parameter sequence may be a singletonstring(e.g.,\"TATA\"), astringvector of single characters (e.g.,\"T\",\"A\",\"T\",\"A\"), or anintegervector (e.g., 3,0,3,0), using SLiM’s standard code of A=0, C=1, G=2, T=3.\n\n(float)nucleotideFrequencies(is sequence)\n\nA convenience function that returns afloatvector of length four, providing the frequencies of occurrences of A / C / G / T nucleotides, respectively, in the supplied nucleotide sequence.The parameter sequence may be a singletonstring(e.g.,\"TATA\"), astringvector of single characters (e.g.,\"T\",\"A\",\"T\",\"A\"), or anintegervector (e.g., 3,0,3,0), using SLiM’s standard code of A=0, C=1, G=2, T=3.\n\n(integer)nucleotidesToCodons(is sequence)\n\nReturns the codon sequence corresponding to the nucleotide sequence insequence.The codon sequence is anintegervector with values from0to63, based upon successive nucleotide triplets in the nucleotide sequence.The codon value for a given nucleotide triplet XYZ is 16X + 4Y + Z, where X, Y, and Z have the usual values A=0, C=1, G=2, T=3.For example, the triplet AAA has a codon value of0, AAC is1, AAG is2, AAT is3, ACA is4, and on upward to TTT which is63.If the nucleotide sequence AACACATTT is passed in, the codon vector1 4 63will therefore be returned.These codon values can be useful in themselves; they can also be passed tocodonsToAminoAcids()to translate them into the corresponding amino acid sequence if desired.\n\nThe nucleotide sequence insequencemay be supplied in any of three formats: astringvector with single-letter nucleotides (e.g.,\"T\",\"A\",\"T\",\"A\"), a singletonstringof nucleotide letters (e.g.,\"TATA\"), or anintegervector of nucleotide values (e.g.,3,0,3,0) using SLiM’s standard code of A=0, C=1, G=2, T=3.If the choice of format is not driven by other considerations, such as ease of manipulation, then the singletonstringformat will certainly be the most memory-efficient for long sequences, and will probably also be the fastest.The nucleotide sequence provided must be a multiple of three in length, so that it translates to an integral number of codons.\n\n"
    },
    "randomNucleotides": {
        "signature": "(is)randomNucleotides(integer$ length, [Nif basis = NULL], [string$ format = \"string\"])",
        "description": "Generates a new random nucleotide sequence withlengthbases.The four nucleotides ACGT are equally probable ifbasisisNULL(the default); otherwise,basismay be a 4-elementintegerorfloatvector providing relative fractions for A, C, G, and T respectively (these need not sum to1.0, as they will be normalized).More complex generative models such as Markov processes are not supported intrinsically in SLiM at this time, but arbitrary generated sequences may always be loaded from files on disk.\n\nTheformatparameter controls the format of the returned sequence.It may be\"string\"to obtain the generated sequence as a singletonstring(e.g.,\"TATA\"),\"char\"to obtain it as astringvector of single characters (e.g.,\"T\",\"A\",\"T\",\"A\"), or\"integer\"to obtain it as anintegervector (e.g.,3,0,3, 0), using SLiM’s standard code of A=0, C=1, G=2, T=3.For passing directly toinitializeAncestralNucleotides(), format\"string\"(a singleton string) will certainly be the most memory-efficient, and probably also the fastest.Memory efficiency can be a significant consideration; the nucleotide sequence for a chromosome of length 109will occupy approximately 1 GB of memory when stored as a singleton string (with one byte per nucleotide), and much more if stored in the other formats.However, the other formats can be easier to work with in Eidos, and so may be preferable for relatively short chromosomes if you are manipulating the generated sequence.\n\n3.3.Population genetics utilities\n\n"
    },
    "calcFST": {
        "signature": "(float$)calcFST(object<Genome> genomes1, object<Genome> genomes2, [No<Mutation> muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])",
        "description": "Calculates theFSTbetween twoGenomevectors – typically, but not necessarily, the genomes that constitute two different subpopulations (which we will assume for the purposes of this discussion).In general, higherFSTindicates greater genetic divergence between subpopulations.\n\nThe calculation is done using only the mutations inmuts; ifmutsisNULL, all mutations are used.Themutsparameter can therefore be used to calculate theFSTonly for a particular mutation type (by passing only mutations of that type).\n\nThe calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [start,end] for the desired window.In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.The default behavior, withstartandendofNULL, provides the genome-wideFST, which is often used to assess the overall level of genetic divergence between sister species or allopatric subpopulations.\n\nThe code forcalcFST()is, roughly, an Eidos implementation of Wright’s definition ofFST(but see below for further discussion and clarification):\n\nFST= 1 -HS/HT\n\nwhereHSis the average heterozygosity in the two subpopulations, andHTis the total heterozygosity when both subpopulations are combined.In this implementation, the two genome vectors are weighted equally, not weighted by their size.In SLiM 3, the implementation followed Wright’s definition closely, and returned theaverage of ratios:mean(1.0 - H_s/H_t), in the Eidos code.In SLiM 4, it returns theratio of averagesinstead:1.0 - mean(H_s)/mean(H_t).In other words, theFSTvalue reported by SLiM 4 is an average across the specified mutations in the two sets of genomes, whereH_sandH_tare first averaged across all specified mutations prior to taking the ratio of the two.This ratio of averages is less biased than the average of ratios, and and is generally considered to be best practice (see, e.g., Bhatia et al., 2013).This means that the behavior ofcalcFST()differs between SLiM 3 and SLiM 4.\n\nThe implementation ofcalcFST(), viewable withfunctionSource(), treats every mutation inmutsas independent in the heterozygosity calculations; in other words, if mutations are stacked, the heterozygosity calculated isby mutation, notby site.Similarly, if multipleMutationobjects exist in different genomes at the same site (whether representing different genetic states, or multiple mutational lineages for the same genetic state), eachMutationobject is treated separately for purposes of the heterozygosity calculation, just as if they were at different sites.One could regard these choices as embodying an infinite-sites interpretation of the segregating mutations.In most biologically realistic models, such genetic states will be quite rare, and so the impact of these choices will be negligible; however, in some models these distinctions may be important.\n\n"
    },
    "calcHeterozygosity": {
        "signature": "(float$)calcHeterozygosity(object<Genome> genomes, [No<Mutation> muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])",
        "description": "Calculates the heterozygosity for a vector of genomes, based upon the frequencies of mutations in the genomes.The result is theexpectedheterozygosity, for the individuals to which the genomes belong, assuming that they are under Hardy-Weinberg equilibrium; this can be compared to theobservedheterozygosity of an individual, as calculated bycalcPairHeterozygosity().Oftengenomeswill be all of the genomes in a subpopulation, or in the entire population, but any genome vector may be used.By default, withmuts=NULL, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations formuts.\n\nThe calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [start,end] for the desired window.In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.The default behavior, withstartandendofNULL, provides the genome-wide heterozygosity.\n\nThe implementation ofcalcHeterozygosity(), viewable withfunctionSource(), treats every mutation as independent in the heterozygosity calculations.One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations.In most biologically realistic models, such genetic states will be quite rare, and so the impact of this choice will be negligible; however, in some models this distinction may be important.SeecalcPairHeterozygosity()for further discussion.\n\n"
    },
    "calcInbreedingLoad": {
        "signature": "(float$)calcInbreedingLoad(object<Genome> genomes, [No<MutationType>$ mutType = NULL])",
        "description": "Calculates inbreeding load (the haploid number of lethal equivalents, orB) for a vector of genomes passed ingenomes.The calculation can be limited to a focal mutation type passed inmutType; ifmutTypeisNULL(the default), all of the mutations for the focal species will be considered.In any case, only deleterious mutations (those with a negative selection coefficient) will be included in the final calculation.\n\nThe inbreeding load is a measure of the quantity of recessive deleterious variation that is heterozygous in a population and can contribute to fitness declines under inbreeding.This function implements the following equation from Morton et al. (1956), which assumes no epistasis and random mating:\n\nB= sum(qs) − sum(q2s) − 2sum(q(1−q)sh)\n\nwhereqis the frequency of a given deleterious allele,sis the absolute value of the selection coefficient, andhis its dominance coefficient.Note that the implementation sets a maximum |s| of1.0(i.e., a lethal allele); |s| can sometimes be greater than1.0whensis drawn from a distribution, but in practice an allele withs<-1.0has the same lethal effect as whens=-1.0.Also note that this implementation will not work when the model changes the dominance coefficients of mutations usingmutationEffect()callbacks, since it relies on thedominanceCoeffproperty ofMutationType. Finally, note that, to estimate the diploid number of lethal equivalents (2B), the result from this function can simply be multiplied by two.\n\nThis function was contributed by Chris Kyriazis; thanks, Chris!\n\n"
    },
    "calcPairHeterozygosity": {
        "signature": "(float$)calcPairHeterozygosity(object<Genome>$ genome1, object<Genome>$ genome2, [Ni$ start = NULL], [Ni$ end = NULL], [logical$ infiniteSites = T])",
        "description": "Calculates the heterozygosity for a pair of genomes; these will typically be the two genomes of a diploid individual (individual.genome1andindividual.genome2), but any two genomes may be supplied.\n\nThe calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [start,end] for the desired window.In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.The default behavior, withstartandendofNULL, provides the genome-wide heterozygosity.\n\nThe implementation ofcalcPairHeterozygosity(), viewable withfunctionSource(), treats every mutation as independent in the heterozygosity calculations by default (i.e., withinfiniteSites=T).If mutations are stacked, the heterozygosity calculated therefore depends upon the number ofunshared mutations, not the number ofdiffering sites.Similarly, if multipleMutationobjects exist in different genomes at the same site (whether representing different genetic states, or multiple mutational lineages for the same genetic state), eachMutationobject is treated separately for purposes of the heterozygosity calculation, just as if they were at different sites.One could regard these choices as embodying an infinite-sites interpretation of the segregating mutations.In most biologically realistic models, such genetic states will be quite rare, and so the impact of this choice will be negligible; however, in some models this distinction may be important.The behavior ofcalcPairHeterozygosity()can be switched to calculate based upon the number of differing sites, rather than the number of unshared mutations, by passinginfiniteSites=F.\n\n"
    },
    "calcPi": {
        "signature": "(float$)calcPi(object<Genome> genomes, [No<Mutation> muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])",
        "description": "Calculatesπ(a metric of genetic diversity based on pairwise sequence differences) for a vector of genomes, based upon the mutations in the genomes.The mathematical formulation (as an estimator of the population parameterθ) is based on work in Nei and Li (1979), Nei and Tajima (1981), and Tajima (1983; equation A3).The exact formula used here is common in textbooks (e.g., equation 3.3 in Hahn 2018, or equation 2.2 in Coop 2020).This value is averaged by the number of sites.\n\nOftengenomeswill be all of the genomes in a subpopulation, or in the entire population, but any genome vector may be used.By default, withmuts=NULL, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations formuts.\n\nThe calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [start,end] for the desired window.In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.The default behavior, withstartandendofNULL, provides the genome-wide value ofπ.\n\nThe implementation ofcalcPi(), viewable withfunctionSource(), treats every mutation as independent in the heterozygosity calculations.One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as withcalcHeterozygosity().Indeed, finite-sites models ofπhave been derived (Tajima 1996) though are not used here.In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.SeecalcPairHeterozygosity()for further discussion.This function was written by Nick Bailey (currently affiliated with CNRS and the Laboratory of Biometry and Evolutionary Biology at University Lyon 1), with helpful input from Peter Ralph.\n\n"
    },
    "calcTajimasD": {
        "signature": "(float$)calcTajimasD(object<Genome> genomes, [No<Mutation> muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])",
        "description": "Calculates Tajima’sD(a test of neutrality based on the allele frequency spectrum) for a vector of genomes, based upon the mutations in the genomes.The mathematical formulation is given in Tajima 1989 (equation 38) and remains unchanged (e.g., equations 2.30 in Durrett 2008, 8.4 in Hahn 2018, and 4.44 in Coop 2020).Oftengenomeswill be all of the genomes in a subpopulation, or in the entire population, but any genome vector may be used.By default, withmuts=NULL, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations formuts.\n\nThe calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [start,end] for the desired window.In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.The default behavior, withstartandendofNULL, provides the genome-wide Tajima’sD.\n\nThe implementation ofcalcTajimasD(), viewable withfunctionSource(), treats every mutation as independent in the heterozygosity calculations.One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as withcalcHeterozygosity().Indeed, Tajima’sDcan be modified with finite-sites models ofπandθ(Misawa and Tajima 1997) though these are not used here.In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.SeecalcPairHeterozygosity()for further discussion.This function was written by Nick Bailey (currently affiliated with CNRS and the Laboratory of Biometry and Evolutionary Biology at University Lyon 1), with helpful input from Peter Ralph.\n\n"
    },
    "calcWattersonsTheta": {
        "signature": "(float$)calcWattersonsTheta(object<Genome> genomes, [No<Mutation> muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])",
        "description": "Calculates Watterson’s theta (a metric of genetic diversity comparable to heterozygosity) for a vector of genomes, based upon the mutations in the genomes.Oftengenomeswill be all of the genomes in a subpopulation, or in the entire population, but any genome vector may be used.By default, withmuts=NULL, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations formuts.\n\nThe calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [start,end] for the desired window.In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.The default behavior, withstartandendofNULL, provides the genome-wide Watterson’s theta.\n\nThe implementation ofcalcWattersonsTheta(), viewable withfunctionSource(), treats every mutation as independent in the heterozygosity calculations.One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as withcalcHeterozygosity().In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.SeecalcPairHeterozygosity()for further discussion.\n\n"
    },
    "calcVA": {
        "signature": "(float$)calcVA(object<Individual> individuals, io<MutationType>$ mutType)",
        "description": "CalculatesVA, the additive genetic variance, among a vectorindividuals, in a particular mutation typemutTypethat represents quantitative trait loci (QTLs) influencing a quantitative phenotypic trait.ThemutTypeparameter may be either anintegerrepresenting the ID of the desired mutation type, or aMutationTypeobject specified directly.\n\nThis function assumes that mutations of typemutTypeencode their effect size upon the quantitative trait in theirselectionCoeffproperty, as is fairly standard in SLiM.The implementation ofcalcVA(), which is viewable withfunctionSource(), is quite simple; if effect sizes are stored elsewhere (such as withsetValue()), a new user-defined function following the pattern ofcalcVA()can easily be written.\n\n3.4.Other utilities\n\n"
    },
    "summarizeIndividuals": {
        "signature": "(float)summarizeIndividuals(object<Individual> individuals, integer dim, numeric spatialBounds, string$ operation, [Nlif$ empty = 0.0], [logical$ perUnitArea = F], [Ns$ spatiality = NULL])",
        "description": "Returns a vector, matrix, or array that summarizes spatial patterns of information related to the individuals inindividuals.In essence, those individuals are assigned intobinsaccording to their spatial position, and then a summary value for each bin is calculated based upon the individuals each bin contains.The individuals might be binned in one dimension (resulting in a vector of summary values), in two dimensions (resulting in a matrix), or in three dimensions (resulting in an array).Typically the spatiality of the result (the dimensions into which the individuals are binned) will match the dimensionality of the model, as indicated by the default value ofNULLfor the optionalspatialityparameter; for example, a two-dimensional (\"xy\") model would by default produce a two-dimensional matrix as a summary.However, a spatiality that is more restrictive than the model dimensionality may be passed; for example, in a two-dimensional (\"xy\") model aspatialityof\"y\"could be passed to summarize individuals into a vector, rather than a matrix, assigning them to bins based only upon theiryposition (i.e., the value of theiryproperty).Whatever spatiality is chosen, the parameterdimprovides the dimensions of the desired result, in the same form that thedim()function does: first the number of rows, then the number of columns, and then the number of planes, as needed (see the Eidos manual for discussion of matrices, arrays, anddim()).The length ofdimsmust match the requested spatiality; for spatiality\"xy\", for example,dimsmight bec(50,100)to request that the returned matrix have50rows and100columns.The result vector/matrix/array is in the correct orientation to be directly usable as a spatial map, by passing it to thedefineSpatialMap()method ofSubpopulation.For further discussion of dimensionality and spatiality, seeinitializeInteractionType()andInteractionType.\n\nThespatialBoundsparameter defines the spatial boundaries within which the individuals are binned.Typically this is the spatial bounds of a particular subpopulation, within which the individuals reside; for individuals inp1, for example, you would likely passp1.spatialBoundsfor this.However, this is not required; individuals may come from any or all subpopulations in the model, andspatialBoundsmay be any bounds of non-zero area (if an individual falls outside of the given spatial bounds, it is excluded, as if it were not inindividualsat all).If you have multiple subpopulations that conceptually reside within the same overall coordinate space, for example, that can be accommodated here.The bounds are supplied in the dimensionality of the model, in the same form as forSubpopulation; for an\"xy\"model, for example, they are supplied as a four-element vector of the formc(x0, y0, x1, y1)even if the summary is being produced with spatiality\"y\".To produce the result, a grid with dimensions defined bydimsis conceptually stretched out across the given spatial bounds, such that thecentersof the edge and corner grid squares are aligned with the limits of the spatial bounds.This matches the way thatdefineSpatialMap()defines its maps.\n\nThe particular summary produced depends upon the parametersoperationandempty.Consider a single grid square represented by a single element in the result.That grid square contains zero or more of the individuals inindividuals.If it contains zero individualsandemptyis notNULL, theemptyvalue is used for the result, regardless ofoperation, providing specific, separate control over the treatment of empty grid squares.IfemptyisNULL, this separate control over the treatment of empty grid squares is declined; empty grid squares will be handled through the standard mechanism described next.In all other cases for the given grid square – when it contains more than zero individuals, or whenemptyisNULL–operationis executed as an Eidoslambda, a small snippet of code, supplied as a singletonstring, that is executed in a manner similar to a function call.Within the execution of theoperationlambda, a constant namedindividualsis defined to be the focal individuals being evaluated – all of the individuals within that grid square.This lambda should evaluate to a singletonlogical,integer, orfloatvalue, comprising the result value for the grid square; these types will all be coerced tofloat(Tbeing1andFbeing0).\n\nTwo examples may illustrate the use ofemptyandoperation.To produce a summary indicating presence/absence, simply use the default of0.0forempty, and\"1.0;\"(or\"1;\", or\"T;\") foroperation.This will produce0.0for empty grid squares, and1.0for those that contain at least one individual.Note that the use ofemptyis essential here, becauseoperationdoesn’t even check whether individuals are present or not.To produce a summary with a count of the number of individuals in each grid square, again use the default of0.0forempty, but now use anoperationof\"individuals.size();\", counting the number of individuals in each grid square.In this case,emptycould beNULLinstead andoperationwould still produce the correct result; but usingemptymakessummarizeIndividuals()more efficient since it allows the execution ofoperationto be skipped for those squares.\n\nLambdas are not limited in their complexity; they can useif,for, etc., and can call methods and functions.A typicaloperationto compute the mean phenotype in a quantitative genetic model that stores phenotype values intagF, for example, would be\"mean(individuals.tagF);\", and this is still quite simple compared to what is possible.However, keep in mind that the lambda will be evaluated for every grid cell (or at least those that are non-empty), so efficiency can be a concern, and you may wish to pre-calculate values shared by all of the lambda calls, making them available to your lambda code usingdefineGlobal()ordefineConstant().\n\nThere is one last twist, ifperUnitAreaisT: values are divided by the area (or length, in 1D, or volume, in 3D) that their corresponding grid cell comprises, so that each value is in units of “per unit area” (or “per unit length”, or “per unit volume”).The total area of the grid is defined by the spatial bounds, and the area of a given grid cell is defined by the portion of the spatial bounds that is within that cell.This is not the same for all grid cells; grid cells that fall partially outsidespatialBounds(because, remember, thecentersof the edge/corner grid cells are aligned with the limits ofspatialBounds) will have a smaller area inside the bounds.For an\"xy\"spatiality summary, for example, corner cells have only a quarter of their area insidespatialBounds, while edge elements have half of their area insidespatialBounds; for purposes ofperUnitArea, then, their respective areas are ¼ and ½ the area of an interior grid cell.By default,perUnitAreaisF, and no scaling is performed.Whether you wantperUnitAreato beForTdepends upon whether the summary you are producing is, conceptually, “per unit area”, such as density (individuals per unit area) or local competition strength (total interaction strength per unit area), or is not, such as “mean individual age”, or “maximumtagvalue”.For the previous example of counting individuals with an operation of\"individuals.size();\", a value ofFforperUnitArea(the default) will produce a simplecountof individuals in each grid square, whereas withTit would produce thedensityof individuals in each grid square.\n\n"
    },
    "treeSeqMetadata": {
        "signature": "(object<Dictionary>$)treeSeqMetadata(string$ filePath, [logical$ userData = T])",
        "description": "Returns aDictionarycontaining top-level metadata from the.trees(tree-sequence) file atfilePath.IfuserDataisT(the default), the top-level metadata under theSLiM/user_metadatakey is returned; this is the same metadata that can optionally be supplied totreeSeqOutput()in itsmetadataparameter, so it makes it easy to recover metadata that you attached to the tree sequence when it was saved.IfuserDataisF, the entire top-level metadataDictionaryobject is returned; this can be useful for examining the values of other keys under theSLiMkey, or values inside the top-level dictionary itself that might have been placed there bymsprimeor other software.\n\nThis function can be used to read in parameter values or other saved state (tagproperty values, for example), in order to resuscitate the complete state of a simulation that was written to a.treesfile.It could be used for more esoteric purposes too, such as to search through.treesfiles in a directory (with the help of the Eidos functionfilesAtPath()) to find those files that satisfy some metadata criterion.\n\n"
    }
}