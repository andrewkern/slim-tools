{
    "// === Chromosome Class Functions ===": {},
    "ancestralNucleotides": {
        "signature": "(is)ancestralNucleotides([Ni$ start = NULL], [Ni$ end = NULL], [string$ format = \"string\"])",
        "description": "Returns the ancestral nucleotide sequence originally supplied to initializeAncestralNucleotides(), including any sequence changes due to nucleotide mutations that have fixed and substituted. This nucleotide sequence is the reference sequence for positions in a genome that do not contain a nucleotide-based mutation. The range of the returned sequence may be constrained by a start position given in start and/or an end position given in end; nucleotides will be returned from start to end, inclusive. The format of the returned sequence is controlled by the format parameter. Supported formats include \"string\" (single sequence string), \"char\" (string vector per nucleotide), \"integer\" (integer vector with values A=0, C=1, G=2, T=3), and \"codon\" (integer values from 0 to 63 based on nucleotide triplets)."
    },
    "drawBreakpoints": {
        "signature": "(integer)drawBreakpoints([No<Individual>$ parent = NULL], [Ni$ n = NULL])",
        "description": "Draw recombination breakpoints using the chromosome's recombination rate map, gene conversion parameters, and applicable recombination() callbacks. The number of breakpoints, n, may be specified; if NULL, it is determined by the recombination rate and chromosome length. If using separate recombination maps for males and females, parent must be provided to select the correct map. If recombination() callbacks are enabled, parent is used to determine pseudo-parameters passed to those callbacks."
    },
    "genomicElementForPosition": {
        "signature": "(object<GenomicElement>)genomicElementForPosition(integer positions)",
        "description": "Returns a vector of GenomicElement objects corresponding to the given base positions along the chromosome. If every position falls within a defined genomic element, the returned vector maintains a one-to-one correspondence with positions. Otherwise, positions that do not fall within genomic elements are excluded from the result."
    },
    "hasGenomicElementForPosition": {
        "signature": "(logical)hasGenomicElementForPosition(integer positions)",
        "description": "Returns a logical vector corresponding to the provided base positions along the chromosome. Each position is marked as T if inside a genomic element, or F if outside. Use genomicElementForPosition() to retrieve the actual GenomicElement objects."
    },
    "setAncestralNucleotides": {
        "signature": "(integer$)setAncestralNucleotides(is sequence)",
        "description": "Replaces the ancestral nucleotide sequence for the model. The sequence parameter is interpreted exactly as in initializeAncestralSequence(). The new sequence length is returned. Replacing the ancestral sequence in a running simulation is uncommon, as it affects segregating and fixed mutations. It can be useful when resetting the simulation state with readFromMS() or readFromVCF()."
    },
    "setGeneConversion": {
        "signature": "(void)setGeneConversion(numeric$ nonCrossoverFraction, numeric$ meanLength, numeric$ simpleConversionFraction, [numeric$ bias = 0])",
        "description": "Switches the recombination model to the \"double-stranded break (DSB)\" model and configures the details of gene conversion tracts. The parameter meanings mirror those of the initializeGeneConversion() function."
    },
    "setHotspotMap": {
        "signature": "(void)setHotspotMap(numeric multipliers, [Ni ends = NULL], [string$ sex = \"*\"])",
        "description": "In nucleotide-based models, sets the mutation rate multiplier along the chromosome. If ends is NULL, a single multiplier applies to the entire chromosome. If ends is supplied, multipliers and ends must be of equal length and define successive contiguous stretches. Sex-specific hotspot maps are supported when specified at initialization."
    },
    "setMutationRate": {
        "signature": "(void)setMutationRate(numeric rates, [Ni ends = NULL], [string$ sex = \"*\"])",
        "description": "Sets the mutation rate per base position per gamete. If ends is NULL, a single mutation rate applies to the entire chromosome. If ends is supplied, rates and ends define successive contiguous stretches. Sex-specific mutation rates are supported if enabled at initialization."
    },
    "setRecombinationRate": {
        "signature": "(void)setRecombinationRate(numeric rates, [Ni ends = NULL], [string$ sex = \"*\"])",
        "description": "Set the recombination rate per base position per gamete. All rates must be in the interval [0.0, 0.5]. If ends is NULL, then rates must be a singleton value that specifies a single recombination rate to be used along the entire chromosome. If ends is supplied, then rates and ends must be the same length, and the values in ends must be specified in ascending order. In that case, rates and ends taken together specify the recombination rates to be used along successive contiguous stretches of the chromosome, from beginning to end; the last position specified in ends should extend to the end of the chromosome. If sex is \"*\" (the default), then the supplied recombination rate map will be used for both sexes (which is the only option for hermaphroditic simulations). In sexual simulations sex may be \"M\" or \"F\" instead, in which case the supplied recombination map is used only for that sex. Note that whether sex-specific recombination maps will be used is set by the way that the simulation is initially configured with initializeRecombinationRate(), and cannot be changed with this method."
    },
    "// === Community Class Functions ===": {},
    "createLogFile": {
        "signature": "(object<LogFile>$)createLogFile(string$ filePath, [Ns initialContents = NULL], [logical$ append = F], [logical$ compress = F], [string$ sep = \",\"], [Ni$ logInterval = NULL], [Ni$ flushInterval = NULL])",
        "description": "Creates and returns a new LogFile object that logs data from the simulation. Data is written to filePath, with optional initialContents written before the header. If append is T, appends to existing file. If compress is T, compresses with zlib. The sep parameter specifies the separator between values (default comma for CSV). Automatic logging occurs every logInterval ticks if specified. With compression, flushInterval controls buffer flushing frequency."
    },
    "estimatedLastTick": {
        "signature": "(integer$)estimatedLastTick()",
        "description": "Returns SLiM's current estimate of the last tick in which the model will execute. This is only an estimate and may change as script blocks are added, removed, or rescheduled."
    },
    "deregisterScriptBlock": {
        "signature": "(void)deregisterScriptBlock(io<SLiMEidosBlock> scriptBlocks)",
        "description": "Schedules specified script blocks for deregistration. Blocks remain valid until after current script block completes. Use block's active property to prevent immediate execution."
    },
    "genomicElementTypesWithIDs": {
        "signature": "(object<GenomicElementType>)genomicElementTypesWithIDs(integer ids)",
        "description": "Returns GenomicElementType objects matching the specified IDs. Errors if any ID is not found."
    },
    "interactionTypesWithIDs": {
        "signature": "(object<InteractionType>)interactionTypesWithIDs(integer ids)",
        "description": "Returns InteractionType objects matching the specified IDs. Errors if any ID is not found."
    },
    "mutationTypesWithIDs": {
        "signature": "(object<MutationType>)mutationTypesWithIDs(integer ids)",
        "description": "Returns MutationType objects matching the specified IDs. Errors if any ID is not found."
    },
    "outputUsage": {
        "signature": "(void)outputUsage()",
        "description": "Outputs current memory usage details to Eidos's output stream. Shows where memory is predominantly used, useful for debugging and optimization."
    },
    "registerEarlyEvent": {
        "signature": "(object<SLiMEidosBlock>$)registerEarlyEvent(Nis$ id, string$ source, [Ni$ start = NULL], [Ni$ end = NULL], [No<Species>$ ticksSpec = NULL])",
        "description": "Registers an early() event with given source code and optional start/end ticks. Returns the new SLiMEidosBlock object. The block is active immediately and may execute in current tick."
    },
    "registerFirstEvent": {
        "signature": "(object<SLiMEidosBlock>$)registerFirstEvent(Nis$ id, string$ source, [Ni$ start = NULL], [Ni$ end = NULL], [No<Species>$ ticksSpec = NULL])",
        "description": "Registers a first() event with given source code and optional start/end ticks. Returns the new SLiMEidosBlock object. The block is active immediately and may execute in current tick."
    },
    "registerInteractionCallback": {
        "signature": "(object<SLiMEidosBlock>$)registerInteractionCallback(Nis$ id, string$ source, io<InteractionType>$ intType, [Nio<Subpopulation>$ subpop = NULL], [Ni$ start = NULL], [Ni$ end = NULL])",
        "description": "Registers an interaction() callback for specified interaction type and optional subpopulation. Returns the new SLiMEidosBlock object. Active immediately for next interaction evaluation."
    },
    "registerLateEvent": {
        "signature": "(object<SLiMEidosBlock>$)registerLateEvent(Nis$ id, string$ source, [Ni$ start = NULL], [Ni$ end = NULL], [No<Species>$ ticksSpec = NULL])",
        "description": "Registers a late() event with given source code and optional start/end ticks. Returns the new SLiMEidosBlock object. The block is active immediately and may execute in current tick."
    },
    "rescheduleScriptBlock": {
        "signature": "(object<SLiMEidosBlock>$)rescheduleScriptBlock(io<SLiMEidosBlock>$ block, [Ni$ start = NULL], [Ni$ end = NULL], [Ni ticks = NULL])",
        "description": "Reschedules a script block to execute in specified ticks. Can use start/end range or explicit tick list. Block may still execute in current tick cycle if previously scheduled."
    },
    "scriptBlocksWithIDs": {
        "signature": "(object<SLiMEidosBlock>)scriptBlocksWithIDs(integer ids)",
        "description": "Returns SLiMEidosBlock objects matching the specified IDs. Errors if any ID is not found."
    },
    "simulationFinished": {
        "signature": "(void)simulationFinished()",
        "description": "Declares the current simulation finished at the end of current tick. Use stop() for immediate termination."
    },
    "speciesWithIDs": {
        "signature": "(object<Species>)speciesWithIDs(integer ids)",
        "description": "Returns Species objects matching the specified IDs. Errors if any ID is not found."
    },
    "subpopulationsWithIDs": {
        "signature": "(object<Subpopulation>)subpopulationsWithIDs(integer ids)",
        "description": "Returns Subpopulation objects matching the specified IDs. Errors if any ID is not found."
    },
    "subpopulationsWithNames": {
        "signature": "(object<Subpopulation>)subpopulationsWithNames(string names)",
        "description": "Returns a vector of Subpopulation objects with the specified names. The names parameter should be a vector of strings matching the names of existing subpopulations."
    },
    "usage": {
        "signature": "(float$)usage()",
        "description": "Returns current memory usage of the simulation. Useful for debugging and optimization. Shows SLiM and Eidos direct memory usage, not total process memory."
    },
    
    "// === Genome Class Functions ===": {},
    "addMutations": {
        "signature": "(void)addMutations(object<Mutation> mutations)",
        "description": "Add the existing mutations in mutations to the genome, if they are not already present (if they are already present, they will be ignored), and if the addition is not prevented by the mutation stacking policy (see the mutationStackPolicy property of MutationType). Calling this will normally affect the fitness values calculated toward the end of the current tick; if you want current fitness values to be affected, you can call the Species method recalculateFitness() – but see the documentation of that method for caveats. Note that in nonWF models that use tree-sequence recording, mutations cannot be added to an individual after the tick in which the individual is created (i.e., when the age of the individual is greater than 0), to prevent the possibility of inconsistencies in the recorded tree sequence."
    },
    "addNewDrawnMutation": {
        "signature": "(object<Mutation>)addNewDrawnMutation(io<MutationType> mutationType, integer position, [Nio<Subpopulation> originSubpop = NULL], [Nis nucleotide = NULL])",
        "description": "Add new mutations to the target genome(s) with the specified mutationType (specified by the MutationType object or by integer identifier), position, and originSubpop (specified by the Subpopulation object or by integer identifier, or by NULL, the default, to specify the subpopulation to which the first target genome belongs). If originSubpop is supplied as an integer, it is intentionally not checked for validity; you may use arbitrary values of originSubpop to 'tag' the mutations that you create. The selection coefficients of the mutations are drawn from their mutation types; addNewMutation() may be used instead if you wish to specify selection coefficients. In non-nucleotide-based models, mutationType will always be a non-nucleotide-based mutation type, and so nucleotide must be NULL (the default). In a nucleotide-based model, mutationType might still be non-nucleotide-based (in which case nucleotide must still be NULL), or mutationType might be nucleotide-based, in which case a non-NULL value must be supplied for nucleotide. The new mutations created by this method are returned, even if their actual addition is prevented by the mutation stacking policy."
    },
    "addNewMutation": {
        "signature": "(object<Mutation>)addNewMutation(io<MutationType> mutationType, numeric selectionCoeff, integer position, [Nio<Subpopulation> originSubpop = NULL], [Nis nucleotide = NULL])",
        "description": "Add new mutations to the target genome(s) with the specified mutationType (specified by the MutationType object or by integer identifier), selectionCoeff, position, and originSubpop (specified by the Subpopulation object or by integer identifier, or by NULL, the default, to specify the subpopulation to which the first target genome belongs). If originSubpop is supplied as an integer, it is intentionally not checked for validity; you may use arbitrary values of originSubpop to 'tag' the mutations that you create. The addNewDrawnMutation() method may be used instead if you wish selection coefficients to be drawn from the mutation types of the mutations."
    },
    "containsMarkerMutation": {
        "signature": "(Nlo<Mutation>$)containsMarkerMutation(io<MutationType>$ mutType, integer$ position, [logical$ returnMutation = F])",
        "description": "Returns T if the genome contains a mutation of type mutType at position, F otherwise (if returnMutation has its default value of F; see below). This method is intended for checking for 'marker mutations': mutations of a special mutation type that are not literally mutations in the usual sense, but instead are added in to particular genomes to mark them as possessing some property."
    },
    "containsMutations": {
        "signature": "(logical)containsMutations(object<Mutation> mutations)",
        "description": "Returns a logical vector indicating whether each of the mutations in mutations is present in the genome; each element in the returned vector indicates whether the corresponding mutation is present (T) or absent (F). This method is provided for speed; it is much faster than the corresponding Eidos code."
    },
    "countOfMutationsOfType": {
        "signature": "(integer$)countOfMutationsOfType(io<MutationType>$ mutType)",
        "description": "Returns the number of mutations that are of the type specified by mutType, out of all of the mutations in the genome. If you need a vector of the matching Mutation objects, rather than just a count, use -mutationsOfType(). This method is provided for speed; it is much faster than the corresponding Eidos code."
    },
    "mutationCountsInGenomes": {
        "signature": "(integer)mutationCountsInGenomes([No<Mutation> mutations = NULL])",
        "description": "Return an integer vector with the frequency counts of all of the Mutation objects passed in mutations, within the target Genome vector. If the optional mutations argument is NULL (the default), frequency counts will be returned for all of the active Mutation objects in the simulation."
    },
    "mutationFrequenciesInGenomes": {
        "signature": "(float)mutationFrequenciesInGenomes([No<Mutation> mutations = NULL])",
        "description": "Return a float vector with the frequencies of all of the Mutation objects passed in mutations, within the target Genome vector. If the optional mutations argument is NULL (the default), frequencies will be returned for all of the active Mutation objects in the simulation."
    },
    "mutationsOfType": {
        "signature": "(object<Mutation>)mutationsOfType(io<MutationType>$ mutType)",
        "description": "Returns an object vector of all the mutations that are of the type specified by mutType, out of all of the mutations in the genome. If you just need a count of the matching Mutation objects, rather than a vector of the matches, use -countOfMutationsOfType()."
    },
    "nucleotides": {
        "signature": "(is)nucleotides([Ni$ start = NULL], [Ni$ end = NULL], [string$ format = \"string\"])",
        "description": "Returns the nucleotide sequence for the genome. This is the current ancestral sequence, as would be returned by the Chromosome method ancestralNucleotides(), with the nucleotides for any nucleotide-based mutations in the genome overlaid."
    },
    "output": {
        "signature": "(void)output([Ns$ filePath = NULL], [logical$ append = F])",
        "description": "Output the target genomes in SLiM's native format. This low-level output method may be used to output any sample of Genome objects."
    },
    "outputMS": {
        "signature": "(void)outputMS([Ns$ filePath = NULL], [logical$ append = F], [logical$ filterMonomorphic = F])",
        "description": "Output the target genomes in MS format. This low-level output method may be used to output any sample of Genome objects."
    },
    "outputVCF": {
        "signature": "(void)outputVCF([Ns$ filePath = NULL], [logical$ outputMultiallelics = T], [logical$ append = F], [logical$ simplifyNucleotides = F], [logical$ outputNonnucleotides = T])",
        "description": "Output the target genomes in VCF format. The target genomes are treated as pairs comprising individuals for purposes of structuring the VCF output, so an even number of genomes is required."
    },
    "positionsOfMutationsOfType": {
        "signature": "(integer)positionsOfMutationsOfType(io<MutationType>$ mutType)",
        "description": "Returns the positions of mutations that are of the type specified by mutType, out of all of the mutations in the genome. If you need a vector of the matching Mutation objects, rather than just positions, use -mutationsOfType()."
    },
    "readFromMS": {
        "signature": "(object<Mutation>)readFromMS(string$ filePath, io<MutationType>$ mutationType)",
        "description": "Read new mutations from the MS format file at filePath and add them to the target genomes. The number of target genomes must match the number of genomes represented in the MS file."
    },
    "readFromVCF": {
        "signature": "(object<Mutation>)readFromVCF(string$ filePath, [Nio<MutationType>$ mutationType = NULL])",
        "description": "Read new mutations from the VCF format file at filePath and add them to the target genomes. The number of target genomes must match the number of genomes represented in the VCF file."
    },
    "removeMutations": {
        "signature": "(void)removeMutations([No<Mutation> mutations = NULL], [logical$ substitute = F])",
        "description": "Remove the mutations in mutations from the target genome(s), if they are present (if they are not present, they will be ignored). If NULL is passed for mutations (which is the default), then all mutations will be removed from the target genomes."
    },
    "sumOfMutationsOfType": {
        "signature": "(float$)sumOfMutationsOfType(io<MutationType>$ mutType)",
        "description": "Returns the sum of the selection coefficients of all mutations that are of the type specified by mutType, out of all of the mutations in the genome. This is often useful in models that use a particular mutation type to represent QTLs with additive effects."
    },
    "// === GenomicElement Class Functions ===": {},
    "setGenomicElementType": {
        "signature": "(void)setGenomicElementType(io<GenomicElementType>$ genomicElementType)}",
        "description": "Set the genomic element type used for a genomic element.  The genomicElementType parameter should supply the new genomic element type for the element, either as a GenomicElementType object or as an integer identifier.  The genomic element type for a genomic element is normally a constant in simulations, so be sure you know what you are doing."
    },

    "// === GenomicElementType Class Functions ===": {},
    "setMutationFractions": {
        "signature": "(void)setMutationFractions(io<MutationType> mutationTypes, numeric proportions)",
        "description":"Set the mutation type fractions contributing to a genomic element type.  The mutationTypes vector should supply the mutation types used by the genomic element (either as MutationType objects or as integer identifiers), and the proportions vector should be of equal length, specifying the relative proportion of mutations that will be drawn from each corresponding type.  This is normally a constant in simulations, so be sure you know what you are doing."
    },
    "setMutationMatrix": {
        "signature": "(void)setMutationMatrix(float mutationMatrix)",
        "description":"Sets a new nucleotide mutation matrix for the genomic element type.  This replaces the mutation matrix originally set by initializeGenomicElementType().  This method may only be called in nucleotide-based models."
    },

    "// === Individual Class Functions ===": {},

 
    "relatedness": {
        "signature": "(float)relatedness(object<Individual> individuals)",
        "description": "Returns a vector containing the degrees of relatedness between the receiver and each of the individuals in individuals. The relatedness between A and B is always 1.0 if A and B are actually the same individual. If pedigree tracking is turned on with initializeSLiMOptions(keepPedigrees=T), this method will use the pedigree information to construct a relatedness estimate. More specifically, this method uses all available pedigree information from the grandparental and parental pedigree records of A and B to compute an estimate of the degree of consanguinity between A and B. Siblings have a relatedness of 0.5, as do parents to their children and vice versa; cousins have a relatedness of 0.125; and so forth."
    },
    "setSpatialPosition": {
        "signature": "(void)setSpatialPosition(float position)",
        "description": "Sets the spatial position of the individual (as accessed through the spatialPosition property). The length of position depends upon the spatial dimensionality declared with initializeSLiMOptions(). If the spatial dimensionality is zero (as it is by default), it is an error to call this method. The elements of position are set into the values of the x, y, and z properties (if those properties are encompassed by the spatial dimensionality of the simulation)."
    },
    "sharedParentCount": {
        "signature": "(integer)sharedParentCount(object<Individual> individuals)",
        "description": "Returns a vector containing the number of parents shared between the receiver and each of the individuals in individuals. The number of shared parents between A and B is always 2 if A and B are actually the same individual. If pedigree tracking is turned on with initializeSLiMOptions(keepPedigrees=T), this method will use the pedigree information to construct a relatedness estimate. More specifically, this method uses the parental pedigree IDs to count the number of shared parents between them, such that full siblings have a count of 2, and half siblings have a count of 1."
    },

    "uniqueMutationsOfType": {
        "signature": "(object<Mutation>)uniqueMutationsOfType(io<MutationType>$ mutType)",
        "description": "Returns an object vector of all the mutations that are of the type specified by mutType, out of all of the mutations in the individual. Mutations present in both genomes will occur only once in the result of this method, and the mutations will be given in sorted order by position. If you just need a count of the matching Mutation objects, rather than a vector of the matches, use -countOfMutationsOfType(). This method is provided for speed; it is much faster than the corresponding Eidos code."
    },


    "// === InteractionType Class Functions ===": {},

    "clippedIntegral": {
        "signature": "(float)clippedIntegral(No<Individual> receivers)",
        "description": "Returns a vector containing the integral of the interaction function as experienced by each of the individuals in receivers. For each given individual, the interaction function is clipped to the edges of the spatial bounds of the subpopulation that individual inhabits. The interaction function is also clipped to the interaction's maximum distance. The evaluate() method must have been previously called for the receiver subpopulation."
    },
    "distance": {
        "signature": "(float)distance(object<Individual>$ receiver, [No<Individual> exerters = NULL])",
        "description": "Returns a vector containing distances between receiver and the individuals in exerters. If exerters is NULL (the default), then a vector of the distances from receiver to all individuals in its subpopulation (including itself) is returned. The evaluate() method must have been previously called for the receiver and exerter subpopulations."
    },
    "distanceFromPoint": {
        "signature": "(float)distanceFromPoint(float point, object<Individual> exerters)",
        "description": "Returns a vector containing distances between the point given by the spatial coordinates in point, which may be thought of as the 'receiver', and individuals in exerters. The point vector is interpreted as providing coordinates precisely as specified by the spatiality of the interaction type."
    },
    "drawByStrength": {
        "signature": "(object)drawByStrength(object<Individual> receiver, [integer$ count = 1], [No<Subpopulation>$ exerterSubpop = NULL], [logical$ returnDict = F])",
        "description": "Returns an object<Individual> vector containing up to count individuals drawn from exerterSubpop, or if that is NULL (the default), then from the subpopulation of receiver. The probability of drawing particular individuals is proportional to the strength of interaction they exert upon receiver."
    },
    "evaluate": {
        "signature": "(void)evaluate(io<Subpopulation> subpops)",
        "description": "Snapshots model state in preparation for the use of the interaction, for the receiver and exerter subpopulations specified by subpops. The subpopulations may be supplied either as integer IDs, or as Subpopulation objects."
    },
    "interactingNeighborCount": {
        "signature": "(integer)interactingNeighborCount(object<Individual> receivers, [No<Subpopulation>$ exerterSubpop = NULL])",
        "description": "Returns the number of interacting individuals for each individual in receivers, within the maximum interaction distance according to the distance metric of the InteractionType, from among the exerters in exerterSubpop."
    },
    "interactionDistance": {
        "signature": "(float)interactionDistance(object<Individual>$ receiver, [No<Individual> exerters = NULL])",
        "description": "Returns a vector containing interaction-dependent distances between receiver and individuals in exerters. If exerters is NULL (the default), then a vector of the interaction-dependent distances from receiver to all individuals in its subpopulation (including receiver itself) is returned."
    },
    "localPopulationDensity": {
        "signature": "(float)localPopulationDensity(object<Individual> receivers, [No<Subpopulation>$ exerterSubpop = NULL])",
        "description": "Returns a vector of the local population density present at the location of each individual in receivers. Population density is estimated using interaction strengths, effectively doing a kernel density estimate using the interaction function as the kernel."
    },
    "nearestInteractingNeighbors": {
        "signature": "(object)nearestInteractingNeighbors(object<Individual> receiver, [integer$ count = 1], [No<Subpopulation>$ exerterSubpop = NULL], [logical$ returnDict = F])",
        "description": "Returns an object<Individual> vector containing up to count interacting individuals that are spatially closest to receiver, according to the distance metric of the InteractionType, from among the exerters in exerterSubpop."
    },
    "nearestNeighbors": {
        "signature": "(object)nearestNeighbors(object<Individual> receiver, [integer$ count = 1], [No<Subpopulation>$ exerterSubpop = NULL], [logical$ returnDict = F])",
        "description": "Returns an object<Individual> vector containing up to count individuals that are spatially closest to receiver, according to the distance metric of the InteractionType, from among the exerters in exerterSubpop."
    },
    "nearestNeighborsOfPoint": {
        "signature": "(object<Individual>)nearestNeighborsOfPoint(float point, io<Subpopulation>$ exerterSubpop, [integer$ count = 1])",
        "description": "Returns up to count individuals in exerterSubpop that are spatially closest to point, according to the distance metric of the InteractionType."
    },
    "neighborCount": {
        "signature": "(integer)neighborCount(object<Individual> receivers, [No<Subpopulation>$ exerterSubpop = NULL])",
        "description": "Returns the number of neighbors for each individual in receivers, within the maximum interaction distance according to the distance metric of the InteractionType, from among the individuals in exerterSubpop."
    },
    "neighborCountOfPoint": {
        "signature": "(integer$)neighborCountOfPoint(float point, io<Subpopulation>$ exerterSubpop)",
        "description": "Returns the number of individuals in exerterSubpop that are within the maximum interaction distance according to the distance metric of the InteractionType."
    },
    "setConstraints": {
        "signature": "(void)setConstraints(string$ who, [Ns$ sex = NULL], [Ni$ tag = NULL], [Ni$ minAge = NULL], [Ni$ maxAge = NULL], [Nl$ migrant = NULL], [Nl$ tagL0 = NULL], [Nl$ tagL1 = NULL], [Nl$ tagL2 = NULL], [Nl$ tagL3 = NULL], [Nl$ tagL4 = NULL])",
        "description": "Sets constraints upon which individuals can be receivers and/or exerters, making the target InteractionType measure interactions between only subsets of the population."
    },
    "setInteractionFunction": {
        "signature": "(void)setInteractionFunction(string$ functionType, ...)",
        "description": "Set the function used to translate spatial distances into interaction strengths for an interaction type. The functionType may be 'f', 'l', 'e', 'n', 'c', or 't', each with their own parameters."
    },
    "strength": {
        "signature": "(float)strength(object<Individual>$ receiver, [No<Individual> exerters = NULL])",
        "description": "Returns a vector containing the interaction strengths exerted upon receiver by the individuals in exerters. If exerters is NULL, then returns strengths from all individuals in receiver's subpopulation."
    },
    "testConstraints": {
        "signature": "(lo<Individual>)testConstraints(object<Individual> individuals, string$ constraints, [logical$ returnIndividuals = F])",
        "description": "Tests the individuals against the interaction constraints specified by constraints. The value of constraints may be 'receiver' to use the receiver constraints, or 'exerter' to use the exerter constraints."
    },
    "totalOfNeighborStrengths": {
        "signature": "(float)totalOfNeighborStrengths(object<Individual> receivers, [No<Subpopulation>$ exerterSubpop = NULL])",
        "description": "Returns a vector of the total interaction strength felt by each individual in receivers by the exerters in exerterSubpop. All receivers must belong to a single subpopulation."
    },
    "unevaluate": {
        "signature": "(void)unevaluate(void)",
        "description": "Discards all evaluation of this interaction, for all subpopulations. The state of the InteractionType is reset to a state prior to evaluation."
    },


    "// === LogFile Class Functions ===": {},


    "addCustomColumn": {
        "signature": "(void)addCustomColumn(string$ columnName, string$ source, [* context = NULL])",
        "description": "Adds a new data column with its name provided by columnName. The new column will be logged each time that a row is generated. The value for the column will be produced by the code supplied in source, which should return either NULL or a singleton value of any non-object type."
    },
    "addCycle": {
        "signature": "(void)addCycle([No<Species>$ species = NULL])",
        "description": "Adds a new data column that provides the cycle counter for species. The column will be named cycle in single-species models; an underscore and the name of the species will be appended in multispecies models."
    },
    "addCycleStage": {
        "signature": "(void)addCycleStage(void)",
        "description": "Adds a new data column that provides the cycle stage, named cycle_stage. The stage is provided as a string, typically 'first', 'early', 'late', or 'end'."
    },
    "addKeysAndValuesFrom": {
        "signature": "(void)addKeysAndValuesFrom(object$ source)",
        "description": "This Dictionary method has an override in LogFile to make it illegal to call, since LogFile manages its Dictionary entries."
    },
    "addMeanSDColumns": {
        "signature": "(void)addMeanSDColumns(string$ columnName, string$ source, [* context = NULL])",
        "description": "Adds two new data columns with names of columnName_mean and columnName_sd. The source code should return either a zero-length vector (resulting in NA) or a non-zero-length vector of integer or float values for mean and standard deviation calculation."
    },
    "addPopulationSexRatio": {
        "signature": "(void)addPopulationSexRatio([No<Species>$ species = NULL])",
        "description": "Adds a new data column that provides the population sex ratio M:(M+F) for species. The column will be named sex_ratio in single-species models; an underscore and species name will be appended in multispecies models."
    },
    "addPopulationSize": {
        "signature": "(void)addPopulationSize([No<Species>$ species = NULL])",
        "description": "Adds a new data column that provides the total population size for species. The column will be named num_individuals in single-species models; an underscore and species name will be appended in multispecies models."
    },
    "addSubpopulationSexRatio": {
        "signature": "(void)addSubpopulationSexRatio(io<Subpopulation>$ subpop)",
        "description": "Adds a new data column that provides the sex ratio M:(M+F) of the subpopulation subpop, named pX_sex_ratio. If the subpopulation exists but has size zero, NA will be written."
    },
    "addSubpopulationSize": {
        "signature": "(void)addSubpopulationSize(io<Subpopulation>$ subpop)",
        "description": "Adds a new data column that provides the size of the subpopulation subpop, named pX_num_individuals. If the subpopulation exists but has size zero, 0 will be written."
    },
    "addSuppliedColumn": {
        "signature": "(void)addSuppliedColumn(string$ columnName)",
        "description": "Adds a new data column with its name provided by columnName. The value is initially undefined (NA) but can be set using setSuppliedValue() before each row is logged."
    },
    "addTick": {
        "signature": "(void)addTick(void)",
        "description": "Adds a new data column, named tick, that provides the tick number for the simulation."
    },
    "clearKeysAndValues": {
        "signature": "(void)clearKeysAndValues(void)",
        "description": "This Dictionary method has an override in LogFile to make it illegal to call, since LogFile manages its Dictionary entries."
    },
    "flush": {
        "signature": "(void)flush(void)",
        "description": "Flushes all buffered data to the output file, synchronously. Note that frequent flushing may impact performance and file size when compression is enabled."
    },
    "logRow": {
        "signature": "(void)logRow(void)",
        "description": "Logs a new row of data by evaluating all of the generators added to the LogFile with add...() calls. The new row may be buffered and not written to disk immediately."
    },
    "setLogInterval": {
        "signature": "(void)setLogInterval([Ni$ logInterval = NULL])",
        "description": "Sets the automatic logging interval. NULL stops automatic logging. Other values request logging every logInterval ticks, starting at the end of the current tick."
    },
    "setFilePath": {
        "signature": "(void)setFilePath(string$ filePath, [Ns initialContents = NULL], [logical$ append = F], [Nl$ compress = NULL], [Ns$ sep = NULL])",
        "description": "Redirects the LogFile to write new rows to a new filePath. Allows starting a new log file with new settings without creating a new LogFile object."
    },
    "setSuppliedValue": {
        "signature": "(void)setSuppliedValue(string$ columnName, +$ value)",
        "description": "Registers a value to be used for the supplied column named columnName when a row is next logged. The column must have been added with addSuppliedColumn()."
    },
    "setValue": {
        "signature": "(void)setValue(is$ key, * value)",
        "description": "This Dictionary method has an override in LogFile to make it illegal to call, since LogFile manages its Dictionary entries."
    },
    "willAutolog": {
        "signature": "(logical$)willAutolog(void)",
        "description": "Returns whether the LogFile is currently configured to perform automatic logging."
    },

    "// === Mutation Class Functions ===": {},


    "setMutationType": {
        "signature": "(void)setMutationType(io<MutationType>$ mutType)",
        "description": "Set the mutation type of the mutation to mutType (which may be specified as either an integer identifier or a MutationType object). This implicitly changes the dominance coefficient of the mutation to that of the new mutation type. The selection coefficient remains unchanged as it is a property of the mutation object itself. In nucleotide-based models, nucleotide-based mutations may not be changed to non-nucleotide-based mutation types and vice versa."
    },
    "setSelectionCoeff": {
        "signature": "(void)setSelectionCoeff(float$ selectionCoeff)",
        "description": "Set the selection coefficient of the mutation to selectionCoeff. The selection coefficient will be changed for all individuals that possess the mutation, since they all share a single Mutation object. The dominance coefficient remains unchanged as it is determined by the mutation type. Often using a mutationEffect() callback is preferable for modifying selection coefficients in a more controlled fashion."
    },
    
    "// === MutationType Class Functions ===": {},
    
    "drawSelectionCoefficient": {
        "signature": "(float)drawSelectionCoefficient([integer$ n = 1])",
        "description": "Draws and returns a vector of n selection coefficients using the currently defined distribution of fitness effects (DFE) for the target mutation type. If the DFE is type 's', this method will result in synchronous execution of the DFE's script."
    },
    "setDistribution": {
        "signature": "(void)setDistribution(string$ distributionType, ...)",
        "description": "Set the distribution of fitness effects for a mutation type. The distributionType may be 'f' (fixed), 'e' (exponential), 'g' (gamma), 'n' (normal), 'p' (Laplace), 'w' (Weibull), or 's' (script). Each type requires specific parameters: 'f' needs fixed selection coefficient; 'e' needs mean; 'g' needs mean and alpha shape; 'n' needs mean and sigma; 'p' needs mean and scale; 'w' needs λ scale and k shape; 's' needs Eidos script. The DFE is normally constant in simulations."
    },

    "// === Plot Class Functions ===": {},

    
    "abline": {
        "signature": "(void)abline([Nif a = NULL], [Nif b = NULL], [Nif h = NULL], [Nif v = NULL], [string color = \"red\"], [numeric lwd = 1.0])",
        "description": "Adds straight lines to the plot. Three modes: 1) lines specified by intercepts (a) and slopes (b), 2) horizontal lines specified by y-values (h), or 3) vertical lines specified by x-values (v). Modes are mutually exclusive. Lines are drawn in specified colors and widths (color and lwd). Each parameter can be singleton or vector matching line count."
    },
    "addLegend": {
        "signature": "(void)addLegend([Ns$ position = NULL], [Ni$ inset = NULL], [Nif$ labelSize = NULL], [Nif$ lineHeight = NULL], [Nif$ graphicsWidth = NULL], [Nif$ exteriorMargin = NULL], [Nif$ interiorMargin = NULL])",
        "description": "Adds a legend to the plot. Position can be 'topRight', 'topLeft', 'bottomRight', or 'bottomLeft'. Controls layout with parameters for label size, line height, graphics width, and margins. Legend entries added separately with legendLineEntry(), legendPointEntry(), or legendSwatchEntry()."
    },
    "axis": {
        "signature": "(void)axis(integer$ side, [Nif at = NULL], [ls labels = T])",
        "description": "Configures plot axis. Side 1 for x-axis (bottom), 2 for y-axis (left). Controls tick positions with 'at' and labels with 'labels' parameter. Labels can be T (numeric positions), F (no labels), or string vector matching 'at' positions."
    },
    "legendLineEntry": {
        "signature": "(void)legendLineEntry(string$ label, [string$ color = \"red\"], [numeric$ lwd = 1.0])",
        "description": "Adds a line segment legend entry with specified label, color, and line width. Can be combined with other entries of same label for composite legend items."
    },
    "legendPointEntry": {
        "signature": "(void)legendPointEntry(string$ label, [integer$ symbol = 0], [string$ color = \"red\"], [string$ border = \"black\"], [numeric$ lwd = 1.0], [numeric$ size = 1.0])",
        "description": "Adds a point symbol legend entry with specified label and appearance parameters. Can be combined with other entries of same label for composite legend items."
    },
    "legendSwatchEntry": {
        "signature": "(void)legendSwatchEntry(string$ label, [string$ color = \"red\"])",
        "description": "Adds a color swatch legend entry with specified label and color. Can be combined with other entries of same label for composite legend items."
    },
    "lines": {
        "signature": "(void)lines(numeric x, numeric y, [string$ color = \"red\"], [numeric$ lwd = 1.0])",
        "description": "Adds connected line segments to plot using x,y coordinates. Lines drawn in specified color and width. Color and width must be singletons; use multiple calls for varying styles."
    },
    "points": {
        "signature": "(void)points(numeric x, numeric y, [integer symbol = 0], [string color = \"red\"], [string border = \"black\"], [numeric lwd = 1.0], [numeric size = 1.0])",
        "description": "Adds point symbols to plot at x,y coordinates. Controls appearance with symbol type, colors, line width, and size. Parameters can be singletons or vectors matching point count."
    },
    "text": {
        "signature": "(void)text(numeric x, numeric y, string labels, [string color = \"black\"], [numeric size = 10.0], [Nif adj = NULL])",
        "description": "Adds text labels to plot at x,y coordinates. Controls appearance with color and font size. Position adjusted with adj parameter for text alignment. Parameters can be singletons or vectors matching label count."
    },
    "write": {
        "signature": "(void)write(string$ filePath)",
        "description": "Writes the plot to a PDF file at the specified path. Suggested to use .pdf extension. Raises error if file cannot be written."
    },

    
    "// === SLiMgui Class Functions ===": {},

    "createPlot": {
        "signature": "(No<Plot>$)createPlot(string$ title, [Nif xrange = NULL], [Nif yrange = NULL], [string$ xlab = \"x\"], [string$ ylab = \"y\"], [Nif$ width = NULL], [Nif$ height = NULL], [logical$ horizontalGrid = F], [logical$ verticalGrid = F], [logical$ fullBox = T], [numeric$ axisLabelSize = 15], [numeric$ tickLabelSize = 10])",
        "description": "Creates or restarts a custom plot with specified title. Controls plot appearance with axis ranges, labels, window size, grid lines, and label sizes. Returns NULL if plot cannot be created (e.g., in SLiMguiLegacy). Plot data can be added using Plot methods like lines(), points(), and text()."
    },
    "logFileData": {
        "signature": "(Nfs)logFileData(object<LogFile>$ logFile, is$ column)",
        "description": "Returns data from specified LogFile column as float vector (if numeric) or string vector (if non-numeric). Returns NULL if column doesn't exist. Only available in SLiMgui where logged data is kept in memory for debugging output viewer."
    },
    "openDocument": {
        "signature": "(void)openDocument(string$ filePath)",
        "description": "Opens document at filePath in SLiMgui. Supports SLiM models (.slim), text files (.txt), and various image formats (PNG, JPG/JPEG, BMP, GIF). In SLiMguiLegacy, supports PDF but not other image formats."
    },
    "pauseExecution": {
        "signature": "(void)pauseExecution(void)",
        "description": "Pauses model execution in SLiMgui at end of current tick. Equivalent to clicking Play button. Execution can be resumed by user. Only works during simple Play mode, not during profiling or forward execution to specific tick."
    },
    "plotWithTitle": {
        "signature": "(No<Plot>$)plotWithTitle(string$ title)",
        "description": "Returns existing plot created by createPlot() with specified title. Returns NULL if no such plot exists. Only accesses plots created through createPlot(), not other SLiMgui plots."
    },

    
    "// === SpatialMap Class Functions ===": {},

    "add": {
        "signature": "(object<SpatialMap>$)add(ifo<SpatialMap> x)",
        "description": "Adds x to each grid value. x can be: singleton value, vector/matrix/array matching grid dimensions, or another SpatialMap. For SpatialMap x, dimensions and bounds must match. Returns target map for chaining."
    },
    "blend": {
        "signature": "(object<SpatialMap>$)blend(ifo<SpatialMap> x, float$ xFraction)",
        "description": "Blends x into map with weight xFraction (in [0,1]). Result is x*xFraction + target*(1-xFraction). x can be: singleton value, vector/matrix/array matching grid dimensions, or another SpatialMap. Returns target map."
    },
    "changeColors": {
        "signature": "(void)changeColors([Nif valueRange = NULL], [Ns colors = NULL])",
        "description": "Changes color scheme. valueRange sets min/max for color mapping, colors specifies color spectrum. Both NULL for default grayscale. Required for mapColor() calls."
    },
    "changeValues": {
        "signature": "(void)changeValues(ifo<SpatialMap> x)",
        "description": "Updates grid values from x (SpatialMap or vector/matrix/array). Grid resolution can change. Preserves color mapping, bounds, and spatiality. Useful for dynamic landscape changes."
    },
    "divide": {
        "signature": "(object<SpatialMap>$)divide(ifo<SpatialMap> x)",
        "description": "Divides map by x. x can be: singleton value, vector/matrix/array matching grid dimensions, or another SpatialMap. For SpatialMap x, dimensions and bounds must match. Returns target map for chaining."
    },
    "exp": {
        "signature": "(object<SpatialMap>$)exp(void)",
        "description": "Exponentiates each grid value x to e^x. Returns target map for chaining operations."
    },
    "gridValues": {
        "signature": "(float)gridValues(void)",
        "description": "Returns grid values as vector (1D), matrix (2D), or array (3D). Format matches that needed by defineSpatialMap() to recreate identical map."
    },
    "interpolate": {
        "signature": "(object<SpatialMap>$)interpolate(integer$ factor, [string$ method = \"linear\"])",
        "description": "Increases grid resolution by factor (2-10001). Methods: 'linear', 'nearest', or 'cubic'. Inserts factor-1 points between existing values. Returns target map for chaining."
    },
    "mapColor": {
        "signature": "(string)mapColor(numeric value)",
        "description": "Translates values to colors using map's color scheme. Requires valueRange and colors to be set. Returns color strings."
    },
    "mapImage": {
        "signature": "(object<Image>$)mapImage([Ni$ width = NULL], [Ni$ height = NULL], [logical$ centers = F], [logical$ color = T])",
        "description": "Creates Image from 2D map. Size from parameters or map. centers=T samples pixel centers, F samples vertices. color=T uses map's color scheme, F creates grayscale."
    },
    "mapValue": {
        "signature": "(float)mapValue(float point)",
        "description": "Translates spatial coordinates to map values. point length must match map spatiality. Supports multiple points. Uses interpolation if enabled. Clamps to spatial bounds."
    },
    "multiply": {
        "signature": "(object<SpatialMap>$)multiply(ifo<SpatialMap> x)",
        "description": "Multiplies map by x. x can be: singleton value, vector/matrix/array matching grid dimensions, or another SpatialMap. For SpatialMap x, dimensions and bounds must match. Returns target map for chaining."
    },
    "power": {
        "signature": "(object<SpatialMap>$)power(ifo<SpatialMap> x)",
        "description": "Raises map values to power x. x can be: singleton value, vector/matrix/array matching grid dimensions, or another SpatialMap. For SpatialMap x, dimensions and bounds must match. Returns target map for chaining."
    },
    "range": {
        "signature": "(float)range(void)",
        "description": "Returns vector of [minimum, maximum] values in map."
    },
    "rescale": {
        "signature": "(object<SpatialMap>$)rescale([numeric$ min = 0.0], [numeric$ max = 1.0])",
        "description": "Rescales map values to range [min, max]. Default [0.0, 1.0]. Requires min < max and finite values. Returns target map for chaining."
    },
    "sampleImprovedNearbyPoint": {
        "signature": "(float)sampleImprovedNearbyPoint(float point, float$ maxDistance, string$ functionType, ...)",
        "description": "Metropolis-Hastings sampling of nearby points. Returns new point if value higher, or probabilistically if lower. Requires non-negative map values. Supports kernels: 'f', 'l', 'e', 'n', 't' (no 3D for 't')."
    },
    "sampleNearbyPoint": {
        "signature": "(float)sampleNearbyPoint(float point, float$ maxDistance, string$ functionType, ...)",
        "description": "Samples nearby point weighted by map values and kernel. Supports kernels: 'f', 'l', 'e', 'n', 't' (no 3D for 't'). Negative map values treated as zero. Respects boundaries."
    },
    "smooth": {
        "signature": "(object<SpatialMap>$)smooth(float$ maxDistance, string$ functionType, ...)",
        "description": "Smooths map by kernel convolution. Kernel types: 'f', 'l', 'e', 'n', 'c', 't'. Handles periodic boundaries. Normalizes kernel to preserve average value. Returns target map for chaining."
    },
    "subtract": {
        "signature": "(object<SpatialMap>$)subtract(ifo<SpatialMap> x)",
        "description": "Subtracts x from map. x can be: singleton value, vector/matrix/array matching grid dimensions, or another SpatialMap. For SpatialMap x, dimensions and bounds must match. Returns target map for chaining."
    },


    "// === Species Class Functions ===": {},
    
    "addSubpop": {
        "signature": "(object<Subpopulation>$)addSubpop(is$ subpopID, integer$ size, [float$ sexRatio = 0.5], [logical$ haploid = F])",
        "description": "Adds new subpopulation with given ID and size. In sexual models, sexRatio controls M:M+F ratio. In nonWF models, haploid=T creates individuals with null second genome. Returns new subpopulation."
    },
    "addSubpopSplit": {
        "signature": "(object<Subpopulation>$)addSubpopSplit(is$ subpopID, integer$ size, io<Subpopulation>$ sourceSubpop, [float$ sexRatio = 0.5])",
        "description": "Creates new subpopulation by splitting from sourceSubpop. Initial individuals are clonal copies from source, chosen by fitness. Returns new subpopulation."
    },
    "individualsWithPedigreeIDs": {
        "signature": "(object<Individual>)individualsWithPedigreeIDs(integer pedigreeIDs, [Nio<Subpopulation> subpops = NULL])",
        "description": "Looks up individuals by pedigree IDs. Requires pedigree tracking enabled. Returns vector of matching individuals. Can search specific subpopulations for efficiency."
    },
    "killIndividuals": {
        "signature": "(void)killIndividuals(object<Individual> individuals)",
        "description": "Immediately kills specified individuals in nonWF models. Removes from subpopulation, keeps in temporary graveyard. Only for nonWF models, not for WF models where mortality is automatic."
    },
    "mutationCounts": {
        "signature": "(integer)mutationCounts(Nio<Subpopulation> subpops, [No<Mutation> mutations = NULL])",
        "description": "Returns frequency counts of mutations in specified subpopulations. If mutations=NULL, counts all active mutations. Can specify subpops=NULL for population-wide counts."
    },
    "mutationFrequencies": {
        "signature": "(float)mutationFrequencies(Nio<Subpopulation> subpops, [No<Mutation> mutations = NULL])",
        "description": "Returns frequencies of mutations in specified subpopulations. If mutations=NULL, calculates for all active mutations. Can specify subpops=NULL for population-wide frequencies."
    },
    "registerFitnessCallback": {
        "signature": "(void)registerFitnessCallback(string$ functionName, [object<MutationType>$ mutType = NULL])",
        "description": "Registers a callback function to calculate fitness effects. If mutType is provided, the callback only applies to mutations of that type."
    },
    "registerMateChoiceCallback": {
        "signature": "(void)registerMateChoiceCallback(string$ functionName)",
        "description": "Registers a callback function to determine mate choice during sexual reproduction."
    },
    "registerModifyChildCallback": {
        "signature": "(void)registerModifyChildCallback(string$ functionName)",
        "description": "Registers a callback function that can modify offspring after they are generated but before they are added to the population."
    },
    "registerMutationCallback": {
        "signature": "(void)registerMutationCallback(string$ functionName)",
        "description": "Registers a callback function that is called whenever new mutations are generated."
    },
    "registerRecombinationCallback": {
        "signature": "(void)registerRecombinationCallback(string$ functionName)",
        "description": "Registers a callback function that is called during recombination to determine breakpoint positions."
    },
    "registerReproductionCallback": {
        "signature": "(void)registerReproductionCallback(string$ functionName)",
        "description": "Registers a callback function that handles reproduction, replacing SLiM's built-in reproduction methods."
    },
    "registerSurvivalCallback": {
        "signature": "(void)registerSurvivalCallback(string$ functionName)",
        "description": "Registers a callback function that determines whether individuals survive between generations."
    },
    "subsetMutations": {
        "signature": "(object<Mutation>)subsetMutations([No<Mutation>$ exclude = NULL], [Nio<MutationType>$ mutType = NULL], [Ni$ position = NULL], [Nis$ nucleotide = NULL], [Ni$ tag = NULL], [Ni$ id = NULL])",
        "description": "Returns a vector of mutations subset from the list of all active mutations in the species (as would be provided by the mutations property).  The parameters specify constraints upon the subset of mutations that will be returned.  Parameter exclude, if non-NULL, may specify a specific mutation that should not be included (typically the focal mutation in some operation).  Parameter mutType, if non-NULL, may specify a mutation type for the mutations to be returned (as either a MutationType object or an integer identifier).  Parameter position, if non-NULL, may specify a base position for the mutations to be returned.  Parameter nucleotide, if non-NULL, may specify a nucleotide for the mutations to be returned (either as a string, \"A\" / \"C\" / \"G\" / \"T\", or as an integer, 0 / 1 / 2 / 3 respectively).  Parameter tag, if non-NULL, may specify a tag value for the mutations to be returned.  Parameter id, if non-NULL, may specify a required value for the id property of the mutations to be returned. \n\n This method is shorthand for getting the mutations property of the subpopulation, and then using operator [] to select only mutations with the desired properties; besides being much simpler than the equivalent Eidos code, it is also much faster.  Note that if you only need to select on mutation type, the mutationsOfType() method will be even faster."
    },
    "treeSeqOutput": {
        "signature": "(void)treeSeqOutput(string$ path, [logical$ binary = T])",
        "description": "Outputs the current tree sequence to a file. If binary is T, the output is in binary format; if F, it is in text format."
    },
    "treeSeqRememberIndividuals": {
        "signature": "(void)treeSeqRememberIndividuals([No<Individual> individuals = NULL], [logical$ permanent = F])",
        "description": "Marks individuals to be remembered in the tree sequence, even after they would normally be garbage-collected. If permanent is T, the individuals will be remembered permanently."
    },
    "treeSeqSimplify": {
        "signature": "(void)treeSeqSimplify([No<Individual> individuals = NULL], [logical$ simplifyAncestry = T])",
        "description": "Simplifies the tree sequence, retaining only the ancestry relevant to the specified individuals. If simplifyAncestry is T, also simplifies the ancestry tree."
    },
    "treeSeqCoalesced": {
        "signature": "(logical$)treeSeqCoalesced()",
        "description": "Returns whether the tree sequence has coalesced to a single common ancestor at all genomic positions."
    },

    "// === Subpopulation Class Functions ===": {},

    "addCloned": {
        "signature": "(object<Individual>)addCloned(object<Individual>$ parent, [integer$ count = 1], [logical$ defer = F])",
        "description": "Generates new offspring by clonal reproduction from parent. Returns vector of new offspring. In spatial models, offspring inherit parent's position. Genome generation can be deferred for parallel processing."
    },
    "addCrossed": {
        "signature": "(object<Individual>)addCrossed(object<Individual>$ parent1, object<Individual>$ parent2, [Nfs$ sex = NULL], [integer$ count = 1], [logical$ defer = F])",
        "description": "Generates offspring through sexual reproduction between parents. In sexual models parent1 must be female. Returns vector of new offspring. Genome generation can be deferred for parallel processing."
    },
    "addEmpty": {
        "signature": "(object<Individual>)addEmpty([Nfs$ sex = NULL], [Nl$ genome1Null = NULL], [Nl$ genome2Null = NULL], [integer$ count = 1])",
        "description": "Creates individuals with empty genomes. Can specify sex and whether genomes are null. Returns vector of new individuals. For nonWF models only."
    },
    "addRecombinant": {
        "signature": "(object<Individual>)addRecombinant(No<Genome>$ strand1, No<Genome>$ strand2, Ni breaks1, No<Genome>$ strand3, No<Genome>$ strand4, Ni breaks2, [Nfs$ sex = NULL], [No<Individual>$ parent1 = NULL], [No<Individual>$ parent2 = NULL], [logical$ randomizeStrands = F], [integer$ count = 1], [logical$ defer = F])",
        "description": "Creates offspring with specified recombination patterns. Highly flexible for custom reproduction schemes. Returns vector of new offspring. For nonWF models only."
    },
    "addSelfed": {
        "signature": "(object<Individual>)addSelfed(object<Individual>$ parent, [integer$ count = 1], [logical$ defer = F])",
        "description": "Generates offspring through self-fertilization. Only for hermaphroditic models. Returns vector of new offspring. Genome generation can be deferred for parallel processing."
    },
    "addSpatialMap": {
        "signature": "(void)addSpatialMap(object<SpatialMap>$ map)",
        "description": "Adds existing SpatialMap to subpopulation. Map must be compatible with subpopulation's spatial bounds and dimensionality."
    },
    "cachedFitness": {
        "signature": "(float)cachedFitness(Ni indices)",
        "description": "Returns cached fitness values for specified individuals. Cannot be called during fitness calculation or from late() events in WF models."
    },
    "configureDisplay": {
        "signature": "(void)configureDisplay([Nf center = NULL], [Nf$ scale = NULL], [Ns$ color = NULL])",
        "description": "Customizes subpopulation display in SLiMgui. Controls position, size, and color of displayed circle."
    },
    "defineSpatialMap": {
        "signature": "(object<SpatialMap>$)defineSpatialMap(string$ name, string$ spatiality, numeric values, [logical$ interpolate = F], [Nif valueRange = NULL], [Ns colors = NULL])",
        "description": "Creates new spatial map for subpopulation. Map is automatically added. Supports various spatiality options and interpolation methods."
    },
    "deviatePositions": {
        "signature": "(void)deviatePositions(No<Individual> individuals, string$ boundary, numeric$ maxDistance, string$ functionType, ...)",
        "description": "Modifies spatial positions of individuals using specified dispersal kernel and boundary conditions. Efficient for modeling movement."
    },
    "outputMSSample": {
        "signature": "(void)outputMSSample(integer$ sampleSize, [logical$ replace = T], [string$ requestedSex = \"*\"], [Ns$ filePath = NULL], [logical$ append = F], [logical$ filterMonomorphic = F])",
        "description": "Outputs random sample in MS format. Can filter by sex and control monomorphic sites. Positions span [0,1]."
    },
    "outputSample": {
        "signature": "(void)outputSample(integer$ sampleSize, [logical$ replace = T], [string$ requestedSex = \"*\"], [Ns$ filePath = NULL], [logical$ append = F])",
        "description": "Outputs random sample in SLiM format. Can sample with/without replacement and filter by sex."
    },
    "outputVCFSample": {
        "signature": "(void)outputVCFSample(integer$ sampleSize, [logical$ replace = T], [string$ requestedSex = \"*\"], [logical$ outputMultiallelics = T], [Ns$ filePath = NULL], [logical$ append = F], [logical$ simplifyNucleotides = F], [logical$ outputNonnucleotides = T])",
        "description": "Outputs random sample in VCF format. Supports various output options for nucleotide and non-nucleotide mutations."
    },
    "pointDeviated": {
        "signature": "(float)pointDeviated(integer$ n, float point, string$ boundary, numeric$ maxDistance, string$ functionType, ...)",
        "description": "Returns points deviated from input using dispersal kernel and boundary conditions. Supports various kernel types and boundaries."
    },
    "pointInBounds": {
        "signature": "(logical)pointInBounds(float point)",
        "description": "Tests if point is within subpopulation's spatial boundaries. Useful for boundary condition implementation."
    },
    "pointPeriodic": {
        "signature": "(float)pointPeriodic(float point)",
        "description": "Wraps points around periodic spatial boundaries. Only affects periodic dimensions, preserves non-periodic coordinates."
    },
    "pointReflected": {
        "signature": "(float)pointReflected(float point)",
        "description": "Reflects points back into spatial boundaries. Useful for implementing reflecting boundary conditions."
    },
    "pointStopped": {
        "signature": "(float)pointStopped(float point)",
        "description": "Clamps points to spatial boundaries. Useful for implementing stopping boundary conditions."
    },
    "pointUniform": {
        "signature": "(float)pointUniform([integer$ n = 1])",
        "description": "Generates random points uniformly distributed within spatial boundaries. Returns n*dimensionality coordinates."
    },
    "removeSpatialMap": {
        "signature": "(void)removeSpatialMap(so<SpatialMap>$ map)",
        "description": "Removes spatial map from subpopulation. Optional but recommended when map no longer needed."
    },
    "removeSubpopulation": {
        "signature": "(void)removeSubpopulation(void)",
        "description": "Removes subpopulation from model. For nonWF models only - WF models should use setSubpopulationSize(0)."
    },
    "sampleIndividuals": {
        "signature": "(object<Individual>)sampleIndividuals(integer$ size, [logical$ replace = F], [No<Individual>$ exclude = NULL], [Ns$ sex = NULL], [Ni$ tag = NULL], [Ni$ minAge = NULL], [Ni$ maxAge = NULL], [Nl$ migrant = NULL], [Nl$ tagL0 = NULL], [Nl$ tagL1 = NULL], [Nl$ tagL2 = NULL], [Nl$ tagL3 = NULL], [Nl$ tagL4 = NULL])",
        "description": "Returns sample of individuals matching specified criteria. Supports various filters including sex, age, tags."
    },
    "setCloningRate": {
        "signature": "(void)setCloningRate(numeric rate)",
        "description": "Sets cloning rate for subpopulation. Can specify different rates by sex in sexual models."
    },
    "setMigrationRates": {
        "signature": "(void)setMigrationRates(io<Subpopulation> sourceSubpops, numeric rates)",
        "description": "Sets migration rates from source subpopulations. Rates specify expected fraction of offspring from each source."
    },
    "setSelfingRate": {
        "signature": "(void)setSelfingRate(numeric$ rate)",
        "description": "Sets selfing rate for subpopulation. Only valid in hermaphroditic models."
    },
    "setSexRatio": {
        "signature": "(void)setSexRatio(float$ sexRatio)",
        "description": "Sets sex ratio (M:M+F) for subpopulation. Takes effect when next generating offspring."
    },
    "setSpatialBounds": {
        "signature": "(void)setSpatialBounds(numeric bounds)",
        "description": "Sets spatial boundaries for subpopulation. Must be set before adding spatial maps."
    },
    "setSubpopulationSize": {
        "signature": "(void)setSubpopulationSize(integer$ size)",
        "description": "Sets target size for subpopulation. Takes effect when next generating offspring."
    },
    "subsetIndividuals": {
        "signature": "(object<Individual>)subsetIndividuals([No<Individual>$ exclude = NULL], [Ns$ sex = NULL], [Ni$ tag = NULL], [Ni$ minAge = NULL], [Ni$ maxAge = NULL], [Nl$ migrant = NULL], [Nl$ tagL0 = NULL], [Nl$ tagL1 = NULL], [Nl$ tagL2 = NULL], [Nl$ tagL3 = NULL], [Nl$ tagL4 = NULL])",
        "description": "Returns subset of individuals matching specified criteria. Supports various filters including sex, age, tags."
    },
    "takeMigrants": {
        "signature": "(void)takeMigrants(object<Individual> migrants)",
        "description": "Immediately moves individuals to this subpopulation. For nonWF models only - WF models use automatic migration."
    },



    "// === Initialization Functions ===": {},


    "initializeAncestralNucleotides": {
        "signature": "(integer$)initializeAncestralNucleotides(is sequence)",
        "description": "Supplies an ancestral nucleotide sequence for nucleotide-based models. The sequence can be: integer vector (A=0,C=1,G=2,T=3), string vector of nucleotides, single string sequence, or path to FASTA file. Only A/C/G/T allowed. Returns sequence length."
    },
    "initializeGeneConversion": {
        "signature": "(void)initializeGeneConversion(numeric$ nonCrossoverFraction, numeric$ meanLength, numeric$ simpleConversionFraction, [numeric$ bias = 0], [logical$ redrawLengthsOnFailure = F])",
        "description": "Configures gene conversion model with DSB parameters: nonCrossover fraction, mean tract length, simple conversion fraction, GC bias, and length redraw option. Bias requires nucleotide-based models."
    },
    "initializeGenomicElement": {
        "signature": "(object<GenomicElement>)initializeGenomicElement(io<GenomicElementType> genomicElementType, integer start, integer end)",
        "description": "Adds genomic element spanning start to end positions. Vectorized for multiple elements. Returns created elements."
    },
    "initializeGenomicElementType": {
        "signature": "(object<GenomicElementType>$)initializeGenomicElementType(is$ id, io<MutationType> mutationTypes, numeric proportions, [Nf mutationMatrix = NULL])",
        "description": "Adds genomic element type with mutation types and proportions. In nucleotide models requires mutation matrix. Returns new type."
    },
    "initializeHotspotMap": {
        "signature": "(void)initializeHotspotMap(numeric multipliers, [Ni ends = NULL], [string$ sex = \"*\"])",
        "description": "Sets mutation rate multipliers along chromosome in nucleotide models. Can specify sex-specific maps."
    },
    "initializeInteractionType": {
        "signature": "(object<InteractionType>$)initializeInteractionType(is$ id, string$ spatiality, [logical$ reciprocal = F], [numeric$ maxDistance = INF], [string$ sexSegregation = \"**\"])",
        "description": "Adds interaction type with spatial dimensions, reciprocality, max distance, and sex constraints. Returns new type."
    },
    "initializeMutationRate": {
        "signature": "(void)initializeMutationRate(numeric rates, [Ni ends = NULL], [string$ sex = \"*\"])",
        "description": "Sets mutation rate per base per gamete. Can specify rates for different regions and sexes."
    },
    "initializeMutationType": {
        "signature": "(object<MutationType>$)initializeMutationType(is$ id, numeric$ dominanceCoeff, string$ distributionType, ...)",
        "description": "Adds mutation type with dominance and selection effects. Distribution types: f(fixed), e(exponential), g(gamma), n(normal), p(laplace), w(weibull), s(script)."
    },
    "initializeMutationTypeNuc": {
        "signature": "(object<MutationType>$)initializeMutationTypeNuc(is$ id, numeric$ dominanceCoeff, string$ distributionType, ...)",
        "description": "Adds nucleotide-based mutation type. Same as initializeMutationType but for nucleotide models only."
    },
    "initializeRecombinationRate": {
        "signature": "(void)initializeRecombinationRate(numeric rates, [Ni ends = NULL], [string$ sex = \"*\"])",
        "description": "Sets recombination rate per base per gamete. Can specify rates for different regions and sexes."
    },
    "initializeSex": {
        "signature": "(void)initializeSex(string$ chromosomeType)",
        "description": "Enables and configures sex in simulation. Chromosome types: A, X, or Y. Makes individuals male/female instead of hermaphroditic."
    },
    "initializeSLiMModelType": {
        "signature": "(void)initializeSLiMModelType(string$ modelType)",
        "description": "Sets model type to WF (Wright-Fisher) or nonWF. Must be called before other initialization."
    },
    "initializeSLiMOptions": {
        "signature": "(void)initializeSLiMOptions([logical$ keepPedigrees = F], [string$ dimensionality = \"\"], [string$ periodicity = \"\"], [integer$ mutationRuns = 0], [logical$ preventIncidentalSelfing = F], [logical$ nucleotideBased = F], [logical$ randomizeCallbacks = T])",
        "description": "Configures simulation options: pedigree tracking, spatial dimensions, periodicity, mutation runs, selfing prevention, nucleotide basis, callback randomization."
    },
    "initializeSpecies": {
        "signature": "(void)initializeSpecies([integer$ tickModulo = 1], [integer$ tickPhase = 1], [string$ avatar = \"\"], [string$ color = \"\"])",
        "description": "Configures species options: activation schedule, visual representation. For multispecies models only."
    },
    "initializeTreeSeq": {
        "signature": "(void)initializeTreeSeq([logical$ recordMutations = T], [Nif$ simplificationRatio = NULL], [Ni$ simplificationInterval = NULL], [logical$ checkCoalescence = F], [logical$ runCrosschecks = F], [logical$ retainCoalescentOnly = T], [Ns$ timeUnit = NULL])",
        "description": "Configures tree sequence recording options: mutation recording, simplification schedule, coalescence checking, crosschecks, retention policy."
    },


    "// === Nucleotide Utility Functions ===": {},

    
    "codonsToNucleotides": {
        "signature": "(is)codonsToNucleotides(integer codons, [string$ format = \"string\"])",
        "description": "Returns the nucleotide sequence corresponding to the codon sequence. Codons use values 0-63 (AAA=0, AAC=1, AAG=2, TTT=63). Format options: 'string' for singleton string, 'char' for string vector, 'integer' for integer vector using A=0,C=1,G=2,T=3."
    },
    "mm16To256": {
        "signature": "(float)mm16To256(float$ mutationMatrix16)",
        "description": "Converts 4×4 mutation matrix to 64×4 matrix where trinucleotide rates depend on central nucleotide. Useful for creating simple trinucleotide-based mutation matrices that can be further modified for specific trinucleotide rates."
    },
    "mmJukesCantor": {
        "signature": "(float)mmJukesCantor(float$ alpha)",
        "description": "Creates Jukes-Cantor (1969) mutation matrix with rate alpha to each alternative nucleotide. Suitable for initializeGenomicElementType(). Total mutation rate is 3*alpha."
    },
    "mmKimura": {
        "signature": "(float)mmKimura(float$ alpha, float$ beta)",
        "description": "Creates Kimura (1980) mutation matrix with transition rate alpha and transversion rate beta. Suitable for initializeGenomicElementType(). Total mutation rate is alpha+2*beta."
    },
    "nucleotideCounts": {
        "signature": "(integer)nucleotideCounts(is sequence)",
        "description": "Returns integer vector [4] counting A/C/G/T occurrences in sequence. Accepts singleton string, string vector, or integer vector (A=0,C=1,G=2,T=3)."
    },
    "nucleotideFrequencies": {
        "signature": "(float)nucleotideFrequencies(is sequence)",
        "description": "Returns float vector [4] with A/C/G/T frequencies in sequence. Accepts singleton string, string vector, or integer vector (A=0,C=1,G=2,T=3)."
    },
    "nucleotidesToCodons": {
        "signature": "(integer)nucleotidesToCodons(is sequence)",
        "description": "Converts nucleotide sequence to codon values 0-63. Codon XYZ value is 16X + 4Y + Z (X,Y,Z using A=0,C=1,G=2,T=3). Accepts string vector, singleton string, or integer vector. Sequence length must be multiple of 3."
    },
    "randomNucleotides": {
        "signature": "(is)randomNucleotides(integer$ length, [Nif basis = NULL], [string$ format = \"string\"])",
        "description": "Generates random nucleotide sequence of given length. With NULL basis uses equal ACGT probabilities, or specify 4-element vector of relative frequencies. Format options: 'string' (most efficient), 'char' (string vector), or 'integer' (A=0,C=1,G=2,T=3)."
    },



    "// === Population Genetics Utility Functions ===": {},


    "calcFST": {
        "signature": "(float$)calcFST(object<Genome> genomes1, object<Genome> genomes2, [No<Mutation> muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])",
        "description": "Calculates FST between two genome vectors, indicating genetic divergence between subpopulations. Uses Wright's FST formula (1 - HS/HT) where HS is average subpopulation heterozygosity and HT is total heterozygosity. In SLiM 4, returns ratio of averages (1.0 - mean(H_s)/mean(H_t)) rather than average of ratios. Supports windowed analysis with start/end parameters."
    },
    "calcHeterozygosity": {
        "signature": "(float$)calcHeterozygosity(object<Genome> genomes, [No<Mutation> muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])",
        "description": "Calculates expected heterozygosity for genome vector under Hardy-Weinberg equilibrium. Can analyze specific mutations or genomic windows. Treats mutations independently using infinite-sites interpretation."
    },
    "calcInbreedingLoad": {
        "signature": "(float$)calcInbreedingLoad(object<Genome> genomes, [No<MutationType>$ mutType = NULL])",
        "description": "Calculates haploid inbreeding load (B) using Morton et al. (1956) equation: B = sum(qs) − sum(q2s) − 2sum(q(1−q)sh). Considers only deleterious mutations, caps |s| at 1.0. Multiply by 2 for diploid load. Requires static dominance coefficients."
    },
    "calcPairHeterozygosity": {
        "signature": "(float$)calcPairHeterozygosity(object<Genome>$ genome1, object<Genome>$ genome2, [Ni$ start = NULL], [Ni$ end = NULL], [logical$ infiniteSites = T])",
        "description": "Calculates heterozygosity between two genomes, typically from a diploid individual. With infiniteSites=T (default) counts unshared mutations; with F counts differing sites. Supports windowed analysis."
    },
    "calcPi": {
        "signature": "(float$)calcPi(object<Genome> genomes, [No<Mutation> muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])",
        "description": "Calculatesπ(a metric of genetic diversity based on pairwise sequence differences) for a vector of genomes, based upon the mutations in the genomes.The mathematical formulation (as an estimator of the population parameterθ) is based on work in Nei and Li (1979), Nei and Tajima (1981), and Tajima (1983; equation A3).The exact formula used here is common in textbooks (e.g., equation 3.3 in Hahn 2018, or equation 2.2 in Coop 2020).This value is averaged by the number of sites.\n\nOftengenomeswill be all of the genomes in a subpopulation, or in the entire population, but any genome vector may be used.By default, withmuts=NULL, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations formuts.\n\nThe calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [start,end] for the desired window.In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.The default behavior, withstartandendofNULL, provides the genome-wide value ofπ.\n\nThe implementation ofcalcPi(), viewable withfunctionSource(), treats every mutation as independent in the heterozygosity calculations.One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as withcalcHeterozygosity().Indeed, finite-sites models ofπhave been derived (Tajima 1996) though are not used here.In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.SeecalcPairHeterozygosity()for further discussion.This function was written by Nick Bailey (currently affiliated with CNRS and the Laboratory of Biometry and Evolutionary Biology at University Lyon 1), with helpful input from Peter Ralph.\n\n"
    },
    "calcTajimasD": {
        "signature": "(float$)calcTajimasD(object<Genome> genomes, [No<Mutation> muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])",
        "description": "Calculates Tajima'sD(a test of neutrality based on the allele frequency spectrum) for a vector of genomes, based upon the mutations in the genomes.The mathematical formulation is given in Tajima 1989 (equation 38) and remains unchanged (e.g., equations 2.30 in Durrett 2008, 8.4 in Hahn 2018, and 4.44 in Coop 2020).Oftengenomeswill be all of the genomes in a subpopulation, or in the entire population, but any genome vector may be used.By default, withmuts=NULL, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations formuts.\n\nThe calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [start,end] for the desired window.In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.The default behavior, withstartandendofNULL, provides the genome-wide Tajima'sD.\n\nThe implementation ofcalcTajimasD(), viewable withfunctionSource(), treats every mutation as independent in the heterozygosity calculations.One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as withcalcHeterozygosity().Indeed, Tajima'sDcan be modified with finite-sites models ofπandθ(Misawa and Tajima 1997) though these are not used here.In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.SeecalcPairHeterozygosity()for further discussion.This function was written by Nick Bailey (currently affiliated with CNRS and the Laboratory of Biometry and Evolutionary Biology at University Lyon 1), with helpful input from Peter Ralph.\n\n"
    },
    "calcWattersonsTheta": {
        "signature": "(float$)calcWattersonsTheta(object<Genome> genomes, [No<Mutation> muts = NULL], [Ni$ start = NULL], [Ni$ end = NULL])",
        "description": "Calculates Watterson's theta (a metric of genetic diversity comparable to heterozygosity) for a vector of genomes, based upon the mutations in the genomes.Oftengenomeswill be all of the genomes in a subpopulation, or in the entire population, but any genome vector may be used.By default, withmuts=NULL, the calculation is based upon all mutations in the simulation; the calculation can instead be based upon a subset of mutations, such as mutations of a specific mutation type, by passing the desired vector of mutations formuts.\n\nThe calculation can be narrowed to apply to only a window – a subrange of the full chromosome – by passing the interval bounds [start,end] for the desired window.In this case, the vector of mutations used for the calculation will be subset to include only mutations within the specified window.The default behavior, withstartandendofNULL, provides the genome-wide Watterson's theta.\n\nThe implementation ofcalcWattersonsTheta(), viewable withfunctionSource(), treats every mutation as independent in the heterozygosity calculations.One could regard this choice as embodying an infinite-sites interpretation of the segregating mutations, as withcalcHeterozygosity().In most biologically realistic models, such genetic states will be quite rare, and so the impact of this assumption will be negligible; however, in some models this distinction may be important.SeecalcPairHeterozygosity()for further discussion.\n\n"
    },
    "calcVA": {
        "signature": "(float$)calcVA(object<Individual> individuals, io<MutationType>$ mutType)",
        "description": "CalculatesVA, the additive genetic variance, among a vectorindividuals, in a particular mutation typemutTypethat represents quantitative trait loci (QTLs) influencing a quantitative phenotypic trait.ThemutTypeparameter may be either anintegerrepresenting the ID of the desired mutation type, or aMutationTypeobject specified directly.\n\nThis function assumes that mutations of typemutTypeencode their effect size upon the quantitative trait in theirselectionCoeffproperty, as is fairly standard in SLiM.The implementation ofcalcVA(), which is viewable withfunctionSource(), is quite simple; if effect sizes are stored elsewhere (such as withsetValue()), a new user-defined function following the pattern ofcalcVA()can easily be written.\n\n"
    },


    "// === Other Utility Functions ===": {},
    "summarizeIndividuals": {
        "signature": "(float)summarizeIndividuals(object<Individual> individuals, integer dim, numeric spatialBounds, string$ operation, [Nlif$ empty = 0.0], [logical$ perUnitArea = F], [Ns$ spatiality = NULL])",
        "description": "Returns a vector, matrix, or array summarizing spatial patterns of individuals. Bins individuals by spatial position and calculates summary values per bin. Result dimensionality matches model dimensionality by default. Supports 1D (vector), 2D (matrix), or 3D (array) outputs. spatialBounds defines binning area, operation lambda determines summary calculation, empty controls empty bin values, and perUnitArea enables per-unit-area scaling."
    },
    "treeSeqMetadata": {
        "signature": "(object<Dictionary>$)treeSeqMetadata(string$ filePath, [logical$ userData = T])",
        "description": "Returns metadata Dictionary from .trees file. With userData=T (default), returns SLiM/user_metadata content matching treeSeqOutput() metadata. With userData=F, returns complete top-level metadata Dictionary. Useful for recovering simulation state or searching tree sequence files by metadata."
    },

    "// === Random Functions (these may be out of order or out of date)===": {},
    
    "setActive": {
        "signature": "(void)setActive(logical$ active)",
        "description": "Sets whether this species is active in the simulation. When a species is inactive, its individuals do not reproduce or undergo selection, but they remain in memory and can be reactivated later."
    },
    "active": {
        "signature": "(logical$)active()",
        "description": "Returns whether this species is currently active in the simulation."
    },
    "tickModulo": {
        "signature": "(integer$)tickModulo()",
        "description": "Returns the tick modulo value for this species, which determines how frequently (in generations) the species participates in the simulation cycle."
    },
    "tickPhase": {
        "signature": "(integer$)tickPhase()",
        "description": "Returns the tick phase value for this species, which determines the offset (in generations) from generation 0 at which the species begins participating in the simulation cycle."
    },
    "values": {
        "signature": "(float)values([Ni$ start = NULL], [Ni$ end = NULL])",
        "description": "Returns the values in the spatial map. If start and end are provided, returns only the values for the specified range of positions. Otherwise returns all values."
    },
    "setValues": {
        "signature": "(void)setValues(float values, [Ni$ start = NULL], [Ni$ end = NULL])",
        "description": "Sets the values in the spatial map. If start and end are provided, sets only the values for the specified range of positions. Otherwise sets all values."
    },
    "dimensionality": {
        "signature": "(string$)dimensionality()",
        "description": "Returns the dimensionality of the spatial map as a string (e.g., \"x\", \"xy\", or \"xyz\")."
    },
    "gridSize": {
        "signature": "(integer$)gridSize()",
        "description": "Returns the size of the grid used by the spatial map in each dimension."
    },
    "spatiality": {
        "signature": "(string$)spatiality()",
        "description": "Returns the spatiality of the map, indicating which spatial dimensions are used (e.g., \"x\", \"xy\", or \"xyz\")."
    },
    "valueAt": {
        "signature": "(float$)valueAt(float position)",
        "description": "Returns the interpolated value of the spatial map at the specified position. The length of the position parameter must match the map's dimensionality."
    },
    "setValueAt": {
        "signature": "(void)setValueAt(float position, float$ value)",
        "description": "Sets the value of the spatial map at the specified position. The length of the position parameter must match the map's dimensionality."
    },
    "spatialBounds": {
        "signature": "(float)spatialBounds()",
        "description": "Returns the spatial bounds of the map as a vector. For 1D maps returns c(x0,x1), for 2D maps returns c(x0,y0,x1,y1), and for 3D maps returns c(x0,y0,z0,x1,y1,z1)."
    },

    "recalculateFitness": {
        "signature": "(void)recalculateFitness()",
        "description": "Forces an immediate recalculation of fitness values for all individuals in the simulation. This is useful when fitness values need to be updated outside of SLiM's normal fitness calculation cycle."
    },


    "outputFasta": {
        "signature": "(void)outputFasta(string$ filePath, [logical$ simplify = T])",
        "description": "Outputs sequences in FASTA format. If simplify is T, outputs the simplified sequence state; if F, outputs the full mutation state."
    },
    "outputFixedMutations": {
        "signature": "(void)outputFixedMutations(string$ filePath, [logical$ append = F])",
        "description": "Outputs all fixed mutations to a file. If append is T, appends to existing file; if F, overwrites it. Each line contains the mutation's position, selection coefficient, and fixation generation."
    },
    "outputFull": {
        "signature": "(void)outputFull(string$ filePath, [logical$ binary = F])",
        "description": "Outputs the complete state of the simulation, including all individuals, mutations, and metadata. If binary is T, outputs in binary format for efficiency; if F, outputs in text format for readability."
    },
    "xy": {
        "signature": "(float)xy()",
        "description": "Returns a two-element float vector containing the x and y coordinates of the individual. Useful in complex spatial models where the spatiality of interactions/maps differs from the overall dimensionality of the model."
    },
    "xyz": {
        "signature": "(float)xyz()",
        "description": "Returns a three-element float vector containing the x, y, and z coordinates of the individual. Useful in complex spatial models where the spatiality of interactions/maps differs from the overall dimensionality of the model."
    },
    "xz": {
        "signature": "(float)xz()",
        "description": "Returns a two-element float vector containing the x and z coordinates of the individual. Useful in complex spatial models where the spatiality of interactions/maps differs from the overall dimensionality of the model."
    },
    "yz": {
        "signature": "(float)yz()",
        "description": "Returns a two-element float vector containing the y and z coordinates of the individual. Useful in complex spatial models where the spatiality of interactions/maps differs from the overall dimensionality of the model."
    },
    "addSubpopulation": {
        "signature": "(object<Subpopulation>)addSubpopulation(integer$ subpopID, integer$ size)",
        "description": "Creates and adds a new subpopulation to the simulation with the specified ID and initial size. Returns the newly created Subpopulation object."
    },

    "subpopulationByID": {
        "signature": "(object<Subpopulation>$)subpopulationByID(integer$ subpopID)",
        "description": "Returns the Subpopulation object with the specified ID. Returns NULL if no such subpopulation exists."
    },
    "countOfSubpopulations": {
        "signature": "(integer$)countOfSubpopulations()",
        "description": "Returns the number of subpopulations currently in the simulation."
    },
    "subpopulations": {
        "signature": "(object<Subpopulation>)subpopulations()",
        "description": "Returns a vector of all Subpopulation objects in the simulation."
    },
    "generation": {
        "signature": "(integer$)generation()",
        "description": "Returns the current generation number in the simulation."
    },
    "modelType": {
        "signature": "(string$)modelType()",
        "description": "Returns the type of SLiM model being used, either \"WF\" for Wright-Fisher or \"nonWF\" for non-Wright-Fisher."
    },
    "sexEnabled": {
        "signature": "(logical$)sexEnabled()",
        "description": "Returns whether sex is enabled in the simulation."
    },
    "spatialDimensionality": {
        "signature": "(integer$)spatialDimensionality()",
        "description": "Returns the number of spatial dimensions in the simulation (0, 1, 2, or 3)."
    },
    "nucleotideValue": {
        "signature": "(integer$)nucleotideValue()",
        "description": "Returns the nucleotide value (0=A, 1=C, 2=G, 3=T) for this mutation. Only valid for nucleotide-based mutations."
    },
    "setNucleotideValue": {
        "signature": "(void)setNucleotideValue(integer$ value)",
        "description": "Sets the nucleotide value (0=A, 1=C, 2=G, 3=T) for this mutation. Only valid for nucleotide-based mutations."
    },
    "isFixed": {
        "signature": "(logical$)isFixed()",
        "description": "Returns whether this mutation has fixed in the population (reached a frequency of 1.0)."
    },
    "originGeneration": {
        "signature": "(integer$)originGeneration()",
        "description": "Returns the generation in which this mutation arose."
    },
    "selectionCoeff": {
        "signature": "(float$)selectionCoeff()",
        "description": "Returns the selection coefficient of this mutation, determining its effect on fitness."
    },

    "subpopID": {
        "signature": "(integer$)subpopID()",
        "description": "Returns the ID of the subpopulation in which this mutation originated."
    },
    "position": {
        "signature": "(integer$)position()",
        "description": "Returns the position of this mutation in the genome."
    },
    "tag": {
        "signature": "(integer$)tag()",
        "description": "Returns the tag value associated with this mutation, which can be used to store arbitrary metadata."
    },
    "setTag": {
        "signature": "(void)setTag(integer$ value)",
        "description": "Sets the tag value associated with this mutation to the specified value."
    }


    

}