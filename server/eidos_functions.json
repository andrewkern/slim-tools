{
  "name": "#### \ud83d\udfe1 `name`\n```slim\nname(params)\n```\n\ud83d\udd35 **Returns:** `return`  \n\ud83d\udfe0 **Parameters:** `params`",
  "abs": "#### \ud83d\udfe1 `abs`\n```slim\nabs(numeric x)\n```\n\ud83d\udd35 **Returns:** `numeric`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "acos": "#### \ud83d\udfe1 `acos`\n```slim\nacos(numeric x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "asin": "#### \ud83d\udfe1 `asin`\n```slim\nasin(numeric x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "atan": "#### \ud83d\udfe1 `atan`\n```slim\natan(numeric x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "atan2": "#### \ud83d\udfe1 `atan2`\n```slim\natan2(numeric x, numeric y)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `numeric x, numeric y`",
  "ceil": "#### \ud83d\udfe1 `ceil`\n```slim\nceil(float x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `float x`",
  "cos": "#### \ud83d\udfe1 `cos`\n```slim\ncos(numeric x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "cumProduct": "#### \ud83d\udfe1 `cumProduct`\n```slim\ncumProduct(numeric x)\n```\n\ud83d\udd35 **Returns:** `numeric`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "cumSum": "#### \ud83d\udfe1 `cumSum`\n```slim\ncumSum(numeric x)\n```\n\ud83d\udd35 **Returns:** `numeric`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "exp": "#### \ud83d\udfe1 `exp`\n```slim\nexp(numeric x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "floor": "#### \ud83d\udfe1 `floor`\n```slim\nfloor(float x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `float x`",
  "integerDiv": "#### \ud83d\udfe1 `integerDiv`\n```slim\nintegerDiv(integer x, integer y)\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `integer x, integer y`",
  "integerMod": "#### \ud83d\udfe1 `integerMod`\n```slim\nintegerMod(integer x, integer y)\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `integer x, integer y`",
  "isFinite": "#### \ud83d\udfe1 `isFinite`\n```slim\nisFinite(float x)\n```\n\ud83d\udd35 **Returns:** `logical`  \n\ud83d\udfe0 **Parameters:** `float x`",
  "isInfinite": "#### \ud83d\udfe1 `isInfinite`\n```slim\nisInfinite(float x)\n```\n\ud83d\udd35 **Returns:** `logical`  \n\ud83d\udfe0 **Parameters:** `float x`",
  "isNAN": "#### \ud83d\udfe1 `isNAN`\n```slim\nisNAN(float x)\n```\n\ud83d\udd35 **Returns:** `logical`  \n\ud83d\udfe0 **Parameters:** `float x`",
  "log": "#### \ud83d\udfe1 `log`\n```slim\nlog(numeric x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "log10": "#### \ud83d\udfe1 `log10`\n```slim\nlog10(numeric x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "log2": "#### \ud83d\udfe1 `log2`\n```slim\nlog2(numeric x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "product": "#### \ud83d\udfe1 `product`\n```slim\nproduct(numeric x)\n```\n\ud83d\udd35 **Returns:** `numeric$`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "round": "#### \ud83d\udfe1 `round`\n```slim\nround(float x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `float x`",
  "setDifference": "#### \ud83d\udfe1 `setDifference`\n```slim\nsetDifference(* x, * y)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `* x, * y`",
  "setIntersection": "#### \ud83d\udfe1 `setIntersection`\n```slim\nsetIntersection(* x, * y)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `* x, * y`",
  "setSymmetricDifference": "#### \ud83d\udfe1 `setSymmetricDifference`\n```slim\nsetSymmetricDifference(* x, * y)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `* x, * y`",
  "setUnion": "#### \ud83d\udfe1 `setUnion`\n```slim\nsetUnion(* x, * y)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `* x, * y`",
  "sin": "#### \ud83d\udfe1 `sin`\n```slim\nsin(numeric x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "sqrt": "#### \ud83d\udfe1 `sqrt`\n```slim\nsqrt(numeric x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "sum": "#### \ud83d\udfe1 `sum`\n```slim\nsum(lif x)\n```\n\ud83d\udd35 **Returns:** `numeric$`  \n\ud83d\udfe0 **Parameters:** `lif x`",
  "sumExact": "#### \ud83d\udfe1 `sumExact`\n```slim\nsumExact(float x)\n```\n\ud83d\udd35 **Returns:** `float$`  \n\ud83d\udfe0 **Parameters:** `float x`",
  "tan": "#### \ud83d\udfe1 `tan`\n```slim\ntan(numeric x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "trunc": "#### \ud83d\udfe1 `trunc`\n```slim\ntrunc(float x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `float x`",
  "cor": "#### \ud83d\udfe1 `cor`\n```slim\ncor(numeric x, numeric y)\n```\n\ud83d\udd35 **Returns:** `float$`  \n\ud83d\udfe0 **Parameters:** `numeric x, numeric y`",
  "cov": "#### \ud83d\udfe1 `cov`\n```slim\ncov(numeric x, numeric y)\n```\n\ud83d\udd35 **Returns:** `float$`  \n\ud83d\udfe0 **Parameters:** `numeric x, numeric y`",
  "max": "#### \ud83d\udfe1 `max`\n```slim\nmax(+ x, ...)\n```\n\ud83d\udd35 **Returns:** `+$`  \n\ud83d\udfe0 **Parameters:** `+ x, ...`",
  "mean": "#### \ud83d\udfe1 `mean`\n```slim\nmean(lif x)\n```\n\ud83d\udd35 **Returns:** `float$`  \n\ud83d\udfe0 **Parameters:** `lif x`",
  "min": "#### \ud83d\udfe1 `min`\n```slim\nmin(+ x, ...)\n```\n\ud83d\udd35 **Returns:** `+$`  \n\ud83d\udfe0 **Parameters:** `+ x, ...`",
  "pmax": "#### \ud83d\udfe1 `pmax`\n```slim\npmax(+ x, + y)\n```\n\ud83d\udd35 **Returns:** `+`  \n\ud83d\udfe0 **Parameters:** `+ x, + y`",
  "pmin": "#### \ud83d\udfe1 `pmin`\n```slim\npmin(+ x, + y)\n```\n\ud83d\udd35 **Returns:** `+`  \n\ud83d\udfe0 **Parameters:** `+ x, + y`",
  "quantile": "#### \ud83d\udfe1 `quantile`\n```slim\nquantile(numeric x, [Nf probs = NULL])\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `numeric x, [Nf probs = NULL]`",
  "range": "#### \ud83d\udfe1 `range`\n```slim\nrange(numeric x, ...)\n```\n\ud83d\udd35 **Returns:** `numeric`  \n\ud83d\udfe0 **Parameters:** `numeric x, ...`",
  "rank": "#### \ud83d\udfe1 `rank`\n```slim\nrank(numeric x, [string$ tiesMethod = \"average\"])\n```\n\ud83d\udd35 **Returns:** `numeric`  \n\ud83d\udfe0 **Parameters:** `numeric x, [string$ tiesMethod = \"average\"]`",
  "sd": "#### \ud83d\udfe1 `sd`\n```slim\nsd(numeric x)\n```\n\ud83d\udd35 **Returns:** `float$`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "ttest": "#### \ud83d\udfe1 `ttest`\n```slim\nttest(float x, [Nf y = NULL], [Nf$ mu = NULL])\n```\n\ud83d\udd35 **Returns:** `float$`  \n\ud83d\udfe0 **Parameters:** `float x, [Nf y = NULL], [Nf$ mu = NULL]`",
  "var": "#### \ud83d\udfe1 `var`\n```slim\nvar(numeric x)\n```\n\ud83d\udd35 **Returns:** `float$`  \n\ud83d\udfe0 **Parameters:** `numeric x`",
  "c": "#### \ud83d\udfe1 `c`\n```slim\nc(...)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `...`",
  "float": "#### \ud83d\udfe1 `float`\n```slim\nfloat(integer$ length)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `integer$ length`",
  "logical": "#### \ud83d\udfe1 `logical`\n```slim\nlogical(integer$ length)\n```\n\ud83d\udd35 **Returns:** `logical`  \n\ud83d\udfe0 **Parameters:** `integer$ length`",
  "object": "#### \ud83d\udfe1 `object`\n```slim\nobject(void)\n```\n\ud83d\udd35 **Returns:** `object<Object>`  \n\ud83d\udfe0 **Parameters:** `void`",
  "rep": "#### \ud83d\udfe1 `rep`\n```slim\nrep(* x, integer$ count)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `* x, integer$ count`",
  "repEach": "#### \ud83d\udfe1 `repEach`\n```slim\nrepEach(* x, integer count)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `* x, integer count`",
  "sample": "#### \ud83d\udfe1 `sample`\n```slim\nsample(* x, integer$ size, [logical$ replace = F], [Nif weights = NULL])\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `* x, integer$ size, [logical$ replace = F], [Nif weights = NULL]`",
  "seq": "#### \ud83d\udfe1 `seq`\n```slim\nseq(n$ from, n$ to, [Nif$ by = NULL], [Ni$ length = NULL])\n```\n\ud83d\udd35 **Returns:** `numeric`  \n\ud83d\udfe0 **Parameters:** `n$ from, n$ to, [Nif$ by = NULL], [Ni$ length = NULL]`",
  "seqAlong": "#### \ud83d\udfe1 `seqAlong`\n```slim\nseqAlong(* x)\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `* x`",
  "seqLen": "#### \ud83d\udfe1 `seqLen`\n```slim\nseqLen(integer$ length)\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `integer$ length`",
  "string": "#### \ud83d\udfe1 `string`\n```slim\nstring(integer$ length)\n```\n\ud83d\udd35 **Returns:** `string`  \n\ud83d\udfe0 **Parameters:** `integer$ length`",
  "all": "#### \ud83d\udfe1 `all`\n```slim\nall(logical x, ...)\n```\n\ud83d\udd35 **Returns:** `logical$`  \n\ud83d\udfe0 **Parameters:** `logical x, ...`",
  "any": "#### \ud83d\udfe1 `any`\n```slim\nany(logical x, ...)\n```\n\ud83d\udd35 **Returns:** `logical$`  \n\ud83d\udfe0 **Parameters:** `logical x, ...`",
  "cat": "#### \ud83d\udfe1 `cat`\n```slim\ncat(* x, [s$ sep = \" \"], [l$ error = F])\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `* x, [s$ sep = \" \"], [l$ error = F]`",
  "catn": "#### \ud83d\udfe1 `catn`\n```slim\ncatn([* x = \"\"], [s$ sep = \" \"], [l$ error = F])\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `[* x = \"\"], [s$ sep = \" \"], [l$ error = F]`",
  "format": "#### \ud83d\udfe1 `format`\n```slim\nformat(string$ format, numeric x)\n```\n\ud83d\udd35 **Returns:** `string`  \n\ud83d\udfe0 **Parameters:** `string$ format, numeric x`",
  "identical": "#### \ud83d\udfe1 `identical`\n```slim\nidentical(* x, * y)\n```\n\ud83d\udd35 **Returns:** `logical$`  \n\ud83d\udfe0 **Parameters:** `* x, * y`",
  "ifelse": "#### \ud83d\udfe1 `ifelse`\n```slim\nifelse(logical test, * trueValues, * falseValues)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `logical test, * trueValues, * falseValues`",
  "length": "#### \ud83d\udfe1 `length`\n```slim\nlength(void)\n```\n\ud83d\udd35 **Returns:** `integer$`  \n\ud83d\udfe0 **Parameters:** `void`",
  "match": "#### \ud83d\udfe1 `match`\n```slim\nmatch(* x, * table)\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `* x, * table`",
  "order": "#### \ud83d\udfe1 `order`\n```slim\norder(+ x, [logical$ ascending = T])\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `+ x, [logical$ ascending = T]`",
  "paste": "#### \ud83d\udfe1 `paste`\n```slim\npaste(..., [string$ sep = \" \"])\n```\n\ud83d\udd35 **Returns:** `string$`  \n\ud83d\udfe0 **Parameters:** `..., [string$ sep = \" \"]`",
  "paste0": "#### \ud83d\udfe1 `paste0`\n```slim\npaste0(...)\n```\n\ud83d\udd35 **Returns:** `string$`  \n\ud83d\udfe0 **Parameters:** `...`",
  "print": "#### \ud83d\udfe1 `print`\n```slim\nprint(* x, [l$ error = F])\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `* x, [l$ error = F]`",
  "rev": "#### \ud83d\udfe1 `rev`\n```slim\nrev(* x)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `* x`",
  "size": "#### \ud83d\udfe1 `size`\n```slim\nsize(void)\n```\n\ud83d\udd35 **Returns:** `integer$`  \n\ud83d\udfe0 **Parameters:** `void`",
  "sort": "#### \ud83d\udfe1 `sort`\n```slim\nsort(+ x, [logical$ ascending = T])\n```\n\ud83d\udd35 **Returns:** `+`  \n\ud83d\udfe0 **Parameters:** `+ x, [logical$ ascending = T]`",
  "sortBy": "#### \ud83d\udfe1 `sortBy`\n```slim\nsortBy(object x, string$ property, [l$ ascending = T])\n```\n\ud83d\udd35 **Returns:** `object`  \n\ud83d\udfe0 **Parameters:** `object x, string$ property, [l$ ascending = T]`",
  "str": "#### \ud83d\udfe1 `str`\n```slim\nstr(void)\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `void`",
  "tabulate": "#### \ud83d\udfe1 `tabulate`\n```slim\ntabulate(integer bin, [Ni$ maxbin = NULL])\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `integer bin, [Ni$ maxbin = NULL]`",
  "unique": "#### \ud83d\udfe1 `unique`\n```slim\nunique(* x, [logical$ preserveOrder = T])\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `* x, [logical$ preserveOrder = T]`",
  "which": "#### \ud83d\udfe1 `which`\n```slim\nwhich(logical x)\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `logical x`",
  "whichMax": "#### \ud83d\udfe1 `whichMax`\n```slim\nwhichMax(+ x)\n```\n\ud83d\udd35 **Returns:** `integer$`  \n\ud83d\udfe0 **Parameters:** `+ x`",
  "whichMin": "#### \ud83d\udfe1 `whichMin`\n```slim\nwhichMin(+ x)\n```\n\ud83d\udd35 **Returns:** `integer$`  \n\ud83d\udfe0 **Parameters:** `+ x`",
  "dmvnorm": "#### \ud83d\udfe1 `dmvnorm`\n```slim\ndmvnorm(float x, numeric mu, numeric sigma)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `float x, numeric mu, numeric sigma`",
  "dbeta": "#### \ud83d\udfe1 `dbeta`\n```slim\ndbeta(float x, numeric alpha, numeric beta)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `float x, numeric alpha, numeric beta`",
  "dexp": "#### \ud83d\udfe1 `dexp`\n```slim\ndexp(float x, [numeric mu = 1])\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `float x, [numeric mu = 1]`",
  "dgamma": "#### \ud83d\udfe1 `dgamma`\n```slim\ndgamma(float x, numeric mean, numeric shape)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `float x, numeric mean, numeric shape`",
  "dnorm": "#### \ud83d\udfe1 `dnorm`\n```slim\ndnorm(float x, [numeric mean = 0], [numeric sd = 1])\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `float x, [numeric mean = 0], [numeric sd = 1]`",
  "pnorm": "#### \ud83d\udfe1 `pnorm`\n```slim\npnorm(float q, [numeric mean = 0], [numeric sd = 1])\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `float q, [numeric mean = 0], [numeric sd = 1]`",
  "qnorm": "#### \ud83d\udfe1 `qnorm`\n```slim\nqnorm(float p, [numeric mean = 0], [numeric sd = 1])\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `float p, [numeric mean = 0], [numeric sd = 1]`",
  "rbeta": "#### \ud83d\udfe1 `rbeta`\n```slim\nrbeta(integer $n, numeric alpha, numeric beta)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `integer $n, numeric alpha, numeric beta`",
  "rbinom": "#### \ud83d\udfe1 `rbinom`\n```slim\nrbinom(integer $n, integer size, float prob)\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `integer $n, integer size, float prob`",
  "rcauchy": "#### \ud83d\udfe1 `rcauchy`\n```slim\nrcauchy(integer $n, [numeric location = 0], [numeric scale = 1])\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `integer $n, [numeric location = 0], [numeric scale = 1]`",
  "rdunif": "#### \ud83d\udfe1 `rdunif`\n```slim\nrdunif(integer $n, [integer min = 0], [integer max = 1])\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `integer $n, [integer min = 0], [integer max = 1]`",
  "rexp": "#### \ud83d\udfe1 `rexp`\n```slim\nrexp(integer $n, [numeric mu = 1])\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `integer $n, [numeric mu = 1]`",
  "rf": "#### \ud83d\udfe1 `rf`\n```slim\nrf(integer $n, numeric d1, numeric d1)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `integer $n, numeric d1, numeric d1`",
  "rgamma": "#### \ud83d\udfe1 `rgamma`\n```slim\nrgamma(integer $n, numeric mean, numeric shape)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `integer $n, numeric mean, numeric shape`",
  "rgeom": "#### \ud83d\udfe1 `rgeom`\n```slim\nrgeom(integer $n, float p)\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `integer $n, float p`",
  "rlnorm": "#### \ud83d\udfe1 `rlnorm`\n```slim\nrlnorm(integer $n, [numeric meanlog = 0], [numeric sdlog = 1])\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `integer $n, [numeric meanlog = 0], [numeric sdlog = 1]`",
  "rmvnorm": "#### \ud83d\udfe1 `rmvnorm`\n```slim\nrmvnorm(integer $n, numeric mu, numeric sigma)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `integer $n, numeric mu, numeric sigma`",
  "rnbinom": "#### \ud83d\udfe1 `rnbinom`\n```slim\nrnbinom(integer $n, integer size, float prob)\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `integer $n, integer size, float prob`",
  "rnorm": "#### \ud83d\udfe1 `rnorm`\n```slim\nrnorm(integer $n, [numeric mean = 0], [numeric sd = 1])\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `integer $n, [numeric mean = 0], [numeric sd = 1]`",
  "rpois": "#### \ud83d\udfe1 `rpois`\n```slim\nrpois(integer $n, numeric lambda)\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `integer $n, numeric lambda`",
  "runif": "#### \ud83d\udfe1 `runif`\n```slim\nrunif(integer $n, [numeric min = 0], [numeric max = 1])\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `integer $n, [numeric min = 0], [numeric max = 1]`",
  "rweibull": "#### \ud83d\udfe1 `rweibull`\n```slim\nrweibull(integer $n, numeric lambda, numeric k)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `integer $n, numeric lambda, numeric k`",
  "asFloat": "#### \ud83d\udfe1 `asFloat`\n```slim\nasFloat(+ x)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `+ x`",
  "asInteger": "#### \ud83d\udfe1 `asInteger`\n```slim\nasInteger(+ x)\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `+ x`",
  "asLogical": "#### \ud83d\udfe1 `asLogical`\n```slim\nasLogical(+ x)\n```\n\ud83d\udd35 **Returns:** `logical`  \n\ud83d\udfe0 **Parameters:** `+ x`",
  "asString": "#### \ud83d\udfe1 `asString`\n```slim\nasString(+ x)\n```\n\ud83d\udd35 **Returns:** `string`  \n\ud83d\udfe0 **Parameters:** `+ x`",
  "elementType": "#### \ud83d\udfe1 `elementType`\n```slim\nelementType(* x)\n```\n\ud83d\udd35 **Returns:** `string$`  \n\ud83d\udfe0 **Parameters:** `* x`",
  "isFloat": "#### \ud83d\udfe1 `isFloat`\n```slim\nisFloat(* x)\n```\n\ud83d\udd35 **Returns:** `logical$`  \n\ud83d\udfe0 **Parameters:** `* x`",
  "isInteger": "#### \ud83d\udfe1 `isInteger`\n```slim\nisInteger(* x)\n```\n\ud83d\udd35 **Returns:** `logical$`  \n\ud83d\udfe0 **Parameters:** `* x`",
  "isLogical": "#### \ud83d\udfe1 `isLogical`\n```slim\nisLogical(* x)\n```\n\ud83d\udd35 **Returns:** `logical$`  \n\ud83d\udfe0 **Parameters:** `* x`",
  "isNULL": "#### \ud83d\udfe1 `isNULL`\n```slim\nisNULL(* x)\n```\n\ud83d\udd35 **Returns:** `logical$`  \n\ud83d\udfe0 **Parameters:** `* x`",
  "isObject": "#### \ud83d\udfe1 `isObject`\n```slim\nisObject(* x)\n```\n\ud83d\udd35 **Returns:** `logical$`  \n\ud83d\udfe0 **Parameters:** `* x`",
  "isString": "#### \ud83d\udfe1 `isString`\n```slim\nisString(* x)\n```\n\ud83d\udd35 **Returns:** `logical$`  \n\ud83d\udfe0 **Parameters:** `* x`",
  "type": "#### \ud83d\udfe1 `type`\n```slim\ntype(* x)\n```\n\ud83d\udd35 **Returns:** `string$`  \n\ud83d\udfe0 **Parameters:** `* x`",
  "createDirectory": "#### \ud83d\udfe1 `createDirectory`\n```slim\ncreateDirectory(string$ path)\n```\n\ud83d\udd35 **Returns:** `logical$`  \n\ud83d\udfe0 **Parameters:** `string$ path`",
  "deleteFile": "#### \ud83d\udfe1 `deleteFile`\n```slim\ndeleteFile(string$ filePath)\n```\n\ud83d\udd35 **Returns:** `logical$`  \n\ud83d\udfe0 **Parameters:** `string$ filePath`",
  "fileExists": "#### \ud83d\udfe1 `fileExists`\n```slim\nfileExists(string$ filePath)\n```\n\ud83d\udd35 **Returns:** `logical$`  \n\ud83d\udfe0 **Parameters:** `string$ filePath`",
  "filesAtPath": "#### \ud83d\udfe1 `filesAtPath`\n```slim\nfilesAtPath(string$ path, [logical$ fullPaths = F])\n```\n\ud83d\udd35 **Returns:** `string`  \n\ud83d\udfe0 **Parameters:** `string$ path, [logical$ fullPaths = F]`",
  "flushFile": "#### \ud83d\udfe1 `flushFile`\n```slim\nflushFile(string$ filePath)\n```\n\ud83d\udd35 **Returns:** `logical$`  \n\ud83d\udfe0 **Parameters:** `string$ filePath`",
  "getwd": "#### \ud83d\udfe1 `getwd`\n```slim\ngetwd(void)\n```\n\ud83d\udd35 **Returns:** `string$`  \n\ud83d\udfe0 **Parameters:** `void`",
  "readFile": "#### \ud83d\udfe1 `readFile`\n```slim\nreadFile(string$ filePath)\n```\n\ud83d\udd35 **Returns:** `string`  \n\ud83d\udfe0 **Parameters:** `string$ filePath`",
  "setwd": "#### \ud83d\udfe1 `setwd`\n```slim\nsetwd(string$ path)\n```\n\ud83d\udd35 **Returns:** `string$`  \n\ud83d\udfe0 **Parameters:** `string$ path`",
  "tempdir": "#### \ud83d\udfe1 `tempdir`\n```slim\ntempdir(void)\n```\n\ud83d\udd35 **Returns:** `string$`  \n\ud83d\udfe0 **Parameters:** `void`",
  "nchar": "#### \ud83d\udfe1 `nchar`\n```slim\nnchar(string x)\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `string x`",
  "strcontains": "#### \ud83d\udfe1 `strcontains`\n```slim\nstrcontains(string x, string$ s, [i$ pos = 0])\n```\n\ud83d\udd35 **Returns:** `logical`  \n\ud83d\udfe0 **Parameters:** `string x, string$ s, [i$ pos = 0]`",
  "strfind": "#### \ud83d\udfe1 `strfind`\n```slim\nstrfind(string x, string$ s, [i$ pos = 0])\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `string x, string$ s, [i$ pos = 0]`",
  "strprefix": "#### \ud83d\udfe1 `strprefix`\n```slim\nstrprefix(string x, string$ s)\n```\n\ud83d\udd35 **Returns:** `logical`  \n\ud83d\udfe0 **Parameters:** `string x, string$ s`",
  "strsplit": "#### \ud83d\udfe1 `strsplit`\n```slim\nstrsplit(string$ x, [string$ sep = \" \"])\n```\n\ud83d\udd35 **Returns:** `string`  \n\ud83d\udfe0 **Parameters:** `string$ x, [string$ sep = \" \"]`",
  "strsuffix": "#### \ud83d\udfe1 `strsuffix`\n```slim\nstrsuffix(string x, string$ s)\n```\n\ud83d\udd35 **Returns:** `logical`  \n\ud83d\udfe0 **Parameters:** `string x, string$ s`",
  "substr": "#### \ud83d\udfe1 `substr`\n```slim\nsubstr(string x, integer first, [Ni last = NULL])\n```\n\ud83d\udd35 **Returns:** `string`  \n\ud83d\udfe0 **Parameters:** `string x, integer first, [Ni last = NULL]`",
  "apply": "#### \ud83d\udfe1 `apply`\n```slim\napply(* x, integer margin, string$ lambdaSource)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `* x, integer margin, string$ lambdaSource`",
  "array": "#### \ud83d\udfe1 `array`\n```slim\narray(* data, integer dim)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `* data, integer dim`",
  "cbind": "#### \ud83d\udfe1 `cbind`\n```slim\ncbind(object source, ...)\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `object source, ...`",
  "diag": "#### \ud83d\udfe1 `diag`\n```slim\ndiag([* x = 1], [Ni$ nrow = NULL], [Ni$ ncol = NULL])\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `[* x = 1], [Ni$ nrow = NULL], [Ni$ ncol = NULL]`",
  "dim": "#### \ud83d\udfe1 `dim`\n```slim\ndim(* x)\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `* x`",
  "drop": "#### \ud83d\udfe1 `drop`\n```slim\ndrop(* x)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `* x`",
  "lowerTri": "#### \ud83d\udfe1 `lowerTri`\n```slim\nlowerTri(* x, [logical$ diag = F])\n```\n\ud83d\udd35 **Returns:** `logical`  \n\ud83d\udfe0 **Parameters:** `* x, [logical$ diag = F]`",
  "matrix": "#### \ud83d\udfe1 `matrix`\n```slim\nmatrix(* data, [Ni$ nrow = NULL], [Ni$ ncol = NULL], [logical$ byrow = F])\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `* data, [Ni$ nrow = NULL], [Ni$ ncol = NULL], [logical$ byrow = F]`",
  "matrixMult": "#### \ud83d\udfe1 `matrixMult`\n```slim\nmatrixMult(numeric x, numeric y)\n```\n\ud83d\udd35 **Returns:** `numeric`  \n\ud83d\udfe0 **Parameters:** `numeric x, numeric y`",
  "ncol": "#### \ud83d\udfe1 `ncol`\n```slim\nncol(* x)\n```\n\ud83d\udd35 **Returns:** `integer$`  \n\ud83d\udfe0 **Parameters:** `* x`",
  "nrow": "#### \ud83d\udfe1 `nrow`\n```slim\nnrow(* x)\n```\n\ud83d\udd35 **Returns:** `integer$`  \n\ud83d\udfe0 **Parameters:** `* x`",
  "rbind": "#### \ud83d\udfe1 `rbind`\n```slim\nrbind(object source, ...)\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `object source, ...`",
  "t": "#### \ud83d\udfe1 `t`\n```slim\nt(* x)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `* x`",
  "upperTri": "#### \ud83d\udfe1 `upperTri`\n```slim\nupperTri(* x, [logical$ diag = F])\n```\n\ud83d\udd35 **Returns:** `logical`  \n\ud83d\udfe0 **Parameters:** `* x, [logical$ diag = F]`",
  "assert": "#### \ud83d\udfe1 `assert`\n```slim\nassert(logical assertions, [Ns$ message = NULL])\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `logical assertions, [Ns$ message = NULL]`",
  "beep": "#### \ud83d\udfe1 `beep`\n```slim\nbeep([Ns$ soundName = NULL])\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `[Ns$ soundName = NULL]`",
  "citation": "#### \ud83d\udfe1 `citation`\n```slim\ncitation(void)\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `void`",
  "clock": "#### \ud83d\udfe1 `clock`\n```slim\nclock([string$ type\u00a0=\u00a0\"cpu\"])\n```\n\ud83d\udd35 **Returns:** `float$`  \n\ud83d\udfe0 **Parameters:** `[string$ type\u00a0=\u00a0\"cpu\"]`",
  "date": "#### \ud83d\udfe1 `date`\n```slim\ndate(void)\n```\n\ud83d\udd35 **Returns:** `string$`  \n\ud83d\udfe0 **Parameters:** `void`",
  "debugIndent": "#### \ud83d\udfe1 `debugIndent`\n```slim\ndebugIndent(void)\n```\n\ud83d\udd35 **Returns:** `string$`  \n\ud83d\udfe0 **Parameters:** `void`",
  "defineConstant": "#### \ud83d\udfe1 `defineConstant`\n```slim\ndefineConstant(string$ symbol, * value)\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `string$ symbol, * value`",
  "defineGlobal": "#### \ud83d\udfe1 `defineGlobal`\n```slim\ndefineGlobal(string$ symbol, * value)\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `string$ symbol, * value`",
  "doCall": "#### \ud83d\udfe1 `doCall`\n```slim\ndoCall(string$ functionName, ...)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `string$ functionName, ...`",
  "executeLambda": "#### \ud83d\udfe1 `executeLambda`\n```slim\nexecuteLambda(string$ lambdaSource, [ls$ timed = F])\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `string$ lambdaSource, [ls$ timed = F]`",
  "exists": "#### \ud83d\udfe1 `exists`\n```slim\nexists(string symbol)\n```\n\ud83d\udd35 **Returns:** `logical`  \n\ud83d\udfe0 **Parameters:** `string symbol`",
  "functionSignature": "#### \ud83d\udfe1 `functionSignature`\n```slim\nfunctionSignature([Ns$ functionName = NULL])\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `[Ns$ functionName = NULL]`",
  "functionSource": "#### \ud83d\udfe1 `functionSource`\n```slim\nfunctionSource(string$ functionName)\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `string$ functionName`",
  "getSeed": "#### \ud83d\udfe1 `getSeed`\n```slim\ngetSeed(void)\n```\n\ud83d\udd35 **Returns:** `integer$`  \n\ud83d\udfe0 **Parameters:** `void`",
  "license": "#### \ud83d\udfe1 `license`\n```slim\nlicense(void)\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `void`",
  "ls": "#### \ud83d\udfe1 `ls`\n```slim\nls([logical$ showSymbolTables = F])\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `[logical$ showSymbolTables = F]`",
  "rm": "#### \ud83d\udfe1 `rm`\n```slim\nrm([Ns variableNames = NULL])\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `[Ns variableNames = NULL]`",
  "sapply": "#### \ud83d\udfe1 `sapply`\n```slim\nsapply(* x, string$ lambdaSource, [string$ simplify = \"vector\"])\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `* x, string$ lambdaSource, [string$ simplify = \"vector\"]`",
  "setSeed": "#### \ud83d\udfe1 `setSeed`\n```slim\nsetSeed(integer$ seed)\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `integer$ seed`",
  "source": "#### \ud83d\udfe1 `source`\n```slim\nsource(string$ filePath, [logical$ chdir = F])\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `string$ filePath, [logical$ chdir = F]`",
  "stop": "#### \ud83d\udfe1 `stop`\n```slim\nstop([Ns$ message = NULL])\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `[Ns$ message = NULL]`",
  "suppressWarnings": "#### \ud83d\udfe1 `suppressWarnings`\n```slim\nsuppressWarnings(logical$ suppress)\n```\n\ud83d\udd35 **Returns:** `logical$`  \n\ud83d\udfe0 **Parameters:** `logical$ suppress`",
  "sysinfo": "#### \ud83d\udfe1 `sysinfo`\n```slim\nsysinfo(string$ key)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `string$ key`",
  "time": "#### \ud83d\udfe1 `time`\n```slim\ntime(void)\n```\n\ud83d\udd35 **Returns:** `string$`  \n\ud83d\udfe0 **Parameters:** `void`",
  "usage": "#### \ud83d\udfe1 `usage`\n```slim\nusage([logical$ peak = F])\n```\n\ud83d\udd35 **Returns:** `float$`  \n\ud83d\udfe0 **Parameters:** `[logical$ peak = F]`",
  "version": "#### \ud83d\udfe1 `version`\n```slim\nversion([logical$ print = T])\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `[logical$ print = T]`",
  "colors": "#### \ud83d\udfe1 `colors`\n```slim\ncolors(numeric x, string$ name)\n```\n\ud83d\udd35 **Returns:** `string`  \n\ud83d\udfe0 **Parameters:** `numeric x, string$ name`",
  "color2rgb": "#### \ud83d\udfe1 `color2rgb`\n```slim\ncolor2rgb(string color)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `string color`",
  "hsv2rgb": "#### \ud83d\udfe1 `hsv2rgb`\n```slim\nhsv2rgb(float hsv)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `float hsv`",
  "rgb2color": "#### \ud83d\udfe1 `rgb2color`\n```slim\nrgb2color(float rgb)\n```\n\ud83d\udd35 **Returns:** `string`  \n\ud83d\udfe0 **Parameters:** `float rgb`",
  "rgb2hsv": "#### \ud83d\udfe1 `rgb2hsv`\n```slim\nrgb2hsv(float rgb)\n```\n\ud83d\udd35 **Returns:** `float`  \n\ud83d\udfe0 **Parameters:** `float rgb`",
  "methodSignature": "#### \ud83d\udfe1 `methodSignature`\n```slim\nmethodSignature([Ns$ methodName])\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `[Ns$ methodName]`",
  "propertySignature": "#### \ud83d\udfe1 `propertySignature`\n```slim\npropertySignature([Ns$ propertyName])\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `[Ns$ propertyName]`",
  "stingRepresentation": "#### \ud83d\udfe1 `stingRepresentation`\n```slim\nstingRepresentation(void)\n```\n\ud83d\udd35 **Returns:** `string$`  \n\ud83d\udfe0 **Parameters:** `void`",
  "Dictionary": "#### \ud83d\udfe1 `Dictionary`\n```slim\nDictionary(string json)\n```\n\ud83d\udd35 **Returns:** `object<Dictionary>$`  \n\ud83d\udfe0 **Parameters:** `string json`",
  "addKeysAndValuesFrom": "#### \ud83d\udfe1 `addKeysAndValuesFrom`\n```slim\naddKeysAndValuesFrom(object$ source)\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `object$ source`",
  "appendKeysAndValuesFrom": "#### \ud83d\udfe1 `appendKeysAndValuesFrom`\n```slim\nappendKeysAndValuesFrom(object source)\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `object source`",
  "clearKeysAndValues": "#### \ud83d\udfe1 `clearKeysAndValues`\n```slim\nclearKeysAndValues(void)\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `void`",
  "compactIndices": "#### \ud83d\udfe1 `compactIndices`\n```slim\ncompactIndices([logical$ preserveOrder = F])\n```\n\ud83d\udd35 **Returns:** `integer`  \n\ud83d\udfe0 **Parameters:** `[logical$ preserveOrder = F]`",
  "getRowValues": "#### \ud83d\udfe1 `getRowValues`\n```slim\ngetRowValues(li index, [logical$ drop = F])\n```\n\ud83d\udd35 **Returns:** `object<Dictionary>$`  \n\ud83d\udfe0 **Parameters:** `li index, [logical$ drop = F]`",
  "getValue": "#### \ud83d\udfe1 `getValue`\n```slim\ngetValue(is$ key)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `is$ key`",
  "identicalContents": "#### \ud83d\udfe1 `identicalContents`\n```slim\nidenticalContents(object$ x)\n```\n\ud83d\udd35 **Returns:** `logical$`  \n\ud83d\udfe0 **Parameters:** `object$ x`",
  "serialize": "#### \ud83d\udfe1 `serialize`\n```slim\nserialize(string$ format)\n```\n\ud83d\udd35 **Returns:** `string`  \n\ud83d\udfe0 **Parameters:** `string$ format`",
  "setValue": "#### \ud83d\udfe1 `setValue`\n```slim\nsetValue(is$ key, * value)\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `is$ key, * value`",
  "DataFrame": "#### \ud83d\udfe1 `DataFrame`\n```slim\nDataFrame(...)\n```\n\ud83d\udd35 **Returns:** `object<Dictionary>$`  \n\ud83d\udfe0 **Parameters:** `...`",
  "asMatrix": "#### \ud83d\udfe1 `asMatrix`\n```slim\nasMatrix(void)\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `void`",
  "subset": "#### \ud83d\udfe1 `subset`\n```slim\nsubset([Nli rows = NULL], [Nlis cols = NULL])\n```\n\ud83d\udd35 **Returns:** `*`  \n\ud83d\udfe0 **Parameters:** `[Nli rows = NULL], [Nlis cols = NULL]`",
  "subsetColumns": "#### \ud83d\udfe1 `subsetColumns`\n```slim\nsubsetColumns(lis index)\n```\n\ud83d\udd35 **Returns:** `object<DataFrame>$`  \n\ud83d\udfe0 **Parameters:** `lis index`",
  "subsetRows": "#### \ud83d\udfe1 `subsetRows`\n```slim\nsubsetRows(li index, [logical$ drop = F])\n```\n\ud83d\udd35 **Returns:** `object<DataFrame>$`  \n\ud83d\udfe0 **Parameters:** `li index, [logical$ drop = F]`",
  "Image": "#### \ud83d\udfe1 `Image`\n```slim\nImage(string$ filePath)\n```\n\ud83d\udd35 **Returns:** `object<Image>$`  \n\ud83d\udfe0 **Parameters:** `string$ filePath`",
  "write": "#### \ud83d\udfe1 `write`\n```slim\nwrite(string$ filePath)\n```\n\ud83d\udd35 **Returns:** `void`  \n\ud83d\udfe0 **Parameters:** `string$ filePath`"
}